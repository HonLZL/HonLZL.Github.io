<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手撕代码</title>
      <link href="/c/shou-si/"/>
      <url>/c/shou-si/</url>
      
        <content type="html"><![CDATA[<h2 id="1-手写-strcpy"><a href="#1-手写-strcpy" class="headerlink" title="1 手写 strcpy"></a>1 手写 strcpy</h2><p> 把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>。要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p><p>该函数返回一个指向最终的目标字符串 dest 的指针。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* strcpy(char* dest, const char* src) {    assert( (dest != nullptr) &amp;&amp; (src != nullptr));    char* p = dest;    while ((*p++ = *src++) != '\0');    // 写开    // while (*src != '\0') {    //     *p = *src;    //     p++; src++;    // }    // *p = '\0';    return dest;}int main() {    char src[] = "Hello, World!";    char dest[5] = {0};  // 目标数组 dest 不够大,会把数据写入到我们无法控制的地址中去    strcpy(dest, src);    printf("复制后的字符串: %s\n", dest);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以有了 <strong>strncpy</strong>, 设置最大复制长度 n</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* strcpy(char* dest, const char* src, size_t n) {    assert( (dest != nullptr) &amp;&amp; (src != nullptr));    char* p = dest;    while (n-- &amp;&amp; (*p++ = *src++) != '\0'); // 不能保证dest 以 '\0' 结尾    while (n-- &gt; 0) {        *p++ = '\0';    }    return dest;}int main() {    char src[] = "Hello, World!";    char dest[5] = {0};     strcpy(dest, src, sizeof(dest));    printf("复制后的字符串: %s\n", dest);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-手写-memcpy"><a href="#2-手写-memcpy" class="headerlink" title="2 手写 memcpy"></a>2 手写 memcpy</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* memcpy(void* dest, const void* src, size_t n) {    // 将源和目标指针分别强制转换为 char* 类型，因为char是C语言中最小的可寻址单位，这样可以确保按字节逐个复制数据。    unsigned char* d = (unsigned char*) dest;    unsigned char* s = (unsigned char*) src;        for (size_t i = 0; i &lt; n; i++) {        d[i] = s[i];    }    return dest;}// 使用struct people{    int iAge;    char szName[12];    char szSex[3];};people stPeople1, stPeople2;// 如果不先清零，那么在赋值之前，这些成员的值可能是随机的，这可能导致意外的结果memset((void*)&amp;stPeople1, 0x00, sizeof(stPeople1));memset((void*)&amp;stPeople2, 0x00, sizeof(stPeople2));stPeople1.iAge = 32;memcpy(stPeople1.szName, "li lei", sizeof(stPeople1.szName));memcpy(stPeople1.szSex, "man", sizeof(stPeople1.szSex));memcpy((void*)&amp;stPeople2, (void*)&amp;stPeople1, sizeof(stPeople2));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>地址重叠问题</strong>是指在复制过程中，源内存区域和目标内存区域有重叠部分，可能导致复制的结果不正确。</p><p>地址堆叠 例如 </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str[] = "Hello, world!";// 将字符串向右移动两个位置，实现地址重叠memcpy(str + 2, str, strlen(str) + 1); // 输出为 HeHeHeHeHeHeHeHe，已经复制的 He 被继续复制到后面的内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-手写-memove"><a href="#3-手写-memove" class="headerlink" title="3 手写 memove"></a>3 手写 memove</h2><p>有重叠时，从后向前复制      </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* memmove(void* dest, const void* src, size_t n) {    unsigned char* d = (unsigned char*)dest;    const unsigned char* s = (const unsigned char*)src;    // 检查源和目标内存区域是否有重叠    if (d &gt; s &amp;&amp; d &lt; s + n) {        // 目标内存区域与源内存区域重叠，从后向前复制        // for (size_t i = n - 1; i &gt;= 0; --i) 死循环        // size_t 是无符号，当 i=0 时 --， 得到的其实是 -1 + 32768 = 32767        // 所以也可以写成  for (size_t i = n - 1; i != -1; --i)        for (size_t i = n; i &gt; 0; --i) {            d[i - 1] = s[i - 1];        }    } else {        // 目标内存区域与源内存区域不重叠，从前向后复制        for (size_t i = 0; i &lt; n; ++i) {            d[i] = s[i];        }    }    return dest;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法同 memcpy</p><h2 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4 单例模式"></a>4 单例模式</h2><p>将单例对象设置为类私有的静态成员，静态成员只能被声明和定义一次，后面使用 get 方法获取这个实例<br>可以保证在整个应用程序的生命周期中，该类只有一个实例</p><p>将构造函数也设置为私有，保证后面不会再去构造这个类了</p><p>饿汉- 线程安全</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton {private:    static Singleton* instance;    // 私有构造函数，防止外部直接创建对象    Singleton() {}public:    // 获取单例实例的静态方法    static Singleton* getInstance() {        return instance;    }    // 示例方法    void showMessage() {        std::cout &lt;&lt; "Hello, Singleton!" &lt;&lt; std::endl;    }};// 在类外初始化静态成员变量Singleton* Singleton::instance = new Singleton();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>懒汉- 线程不安全，获取单例的时候才去新建它，使用双重检查锁来确保线程安全</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton {private:  static Singleton* instance;  static std::mutex mtx;  Singleton(){    cout &lt;&lt; " contructor " &lt;&lt; endl;  }public:  static Singleton* getInstance() {    if (!instance) {      std::lock_guard&lt;std::mutex&gt; lock(mtx);      // 双重检查，保证只有需要创建的时候，才锁住      if (!instance) {          instance = new Singleton();      }    }    return instance;  }};// 静态成员变量需要在类外初始化Singleton* Singleton::instance = nullptr;std::mutex Singleton::mtx;int main() {  Singleton* instance =  Singleton::getInstance();  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-深拷贝"><a href="#5-深拷贝" class="headerlink" title="5 深拷贝"></a>5 深拷贝</h2><p>深浅拷贝同常针对于指针，其他类型的复制都是深拷贝</p><p>指针的浅拷贝是指两个元素的地址是一样的，没有重新分配内存并复制指针所指向的数据。<br>深拷贝是重新申请内存了，地址也不一样</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Obj {private:    int a[10];    char* b;public:    // 构造函数    Obj() {        b = new char[100]; // 分配内存        std::strcpy(b, "Default string");    }    // 复制构造函数    Obj(const Obj&amp; other) {        // 深拷贝数组成员 a        std::memcpy(a, other.a, sizeof(a));        // 深拷贝字符串成员 b        b = new char[std::strlen(other.b) + 1]; // 分配内存        std::strcpy(b, other.b);    }    // 析构函数    ~Obj() {        delete[] b; // 释放内存    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-智能指针"><a href="#6-智能指针" class="headerlink" title="6  智能指针"></a>6  智能指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;/*  uses 作用  用来标记被管理对象的生命周期，原始指针*//*  weaks 作用  用来标记管理对象的生命周期, 计数器*/// 当一个shared_ptr超出作用域被销毁时，它会调用其_share_count的_M_reset()对uses和weaks进行自减并判断是否需要释放管理对象和被管理对象// 之所以用到 weak，是因为源码在释放资源的时候，用的是引用类的删除，删除的是指针的拷贝对象，例如下面代码，p = nullptr 是无效的，使用无法使用 空指针判断 原始资源也没有释放/*void func(int* p) {  delete p;  p = nullptr;  // 置空也没有用}int main() {  int* p = new int(2);  func(p);  cout &lt;&lt; *p &lt;&lt; endl;  // p 是野指针，不是 nullptr}*/// 为什么使用ref类内的 拷贝 去释放资源呢class Counter { public:     int uses = 1;    // use_count    int weaks = 1;   // weak_count + (use_count != 0) };template &lt;typename T&gt;class weak_ptr;template &lt;typename T&gt;class shared_ptr {public:    // 默认构造函数，创建一个空的shared_ptr    shared_ptr() : ptr_(nullptr), counter_(new Counter()) {}    // 从原始指针构造shared_ptr    explicit shared_ptr(T* ptr) : ptr_(ptr), counter_(new Counter()) {}    // 拷贝构造函数    shared_ptr(const shared_ptr&amp; other)        : ptr_(other.ptr_), counter_(other.counter_)    {        ++counter_-&gt;uses;    }    // 移动构造函数    shared_ptr(shared_ptr&amp;&amp; other) noexcept        : ptr_(other.ptr_), counter_(other.counter_)    {        other.ptr_ = nullptr;        other.counter_ = nullptr;    }    // 从 weak_ptr 构造 shared_ptr    shared_ptr(const weak_ptr&lt;T&gt;&amp; other)    {        if (!other.expired()) {            ptr_ = other.ptr_;            counter_ = other.counter_;            ++counter_-&gt;uses;        }    }    // 赋值操作符    shared_ptr&amp; operator=(const shared_ptr&amp; other)    {        reset();        ptr_ = other.ptr_;        counter_ = other.counter_;        ++counter_-&gt;uses;        return *this;    }    // 移动赋值操作符    shared_ptr&amp; operator=(shared_ptr&amp;&amp; other) noexcept    {        reset();        ptr_ = other.ptr_;        counter_ = other.counter_;        other.ptr_ = nullptr;        other.counter_ = nullptr;        return *this;    }    // 析构函数    ~shared_ptr()    {        reset();    }    // 重置shared_ptr    void reset()    {        if (counter_) {            if (--counter_-&gt;uses == 0) {                if (ptr_) {                    delete ptr_;                    ptr_ = nullptr;                }                if (counter_-&gt;weaks == 0) {                    delete counter_;                    counter_ = nullptr;                }            }        }    }        int use_count() const { return counter_ ? counter_-&gt;uses : 0; }    // 获取原始指针    T* get() const { return ptr_; }    // 解引用操作符    T&amp; operator*() const { return *ptr_; }    // 操作符-&gt;    T* operator-&gt;() const { return ptr_; }    // 检查shared_ptr是否为空    bool empty() const { return ptr_ == nullptr; }private:    T* ptr_ = nullptr;    Counter* counter_ = nullptr;    friend class weak_ptr&lt;T&gt;;};template &lt;typename T&gt;class weak_ptr {public:    // 默认构造函数，创建一个空的weak_ptr    weak_ptr() : ptr_(nullptr), counter_(nullptr) {}    // 从shared_ptr构造weak_ptr    weak_ptr(const shared_ptr&lt;T&gt;&amp; other)        : ptr_(other.ptr_), counter_(other.counter_)    {        if (counter_)            ++counter_-&gt;weaks;    }    // 拷贝构造函数    weak_ptr(const weak_ptr&amp; other)        : ptr_(other.ptr_), counter_(other.counter_)    {        if (counter_)            ++counter_-&gt;weaks;    }    // 移动构造函数    weak_ptr(weak_ptr&amp;&amp; other) noexcept        : ptr_(other.ptr_), counter_(other.counter_)    {        other.ptr_ = nullptr;        other.counter_ = nullptr;    }    // 赋值操作符    weak_ptr&amp; operator=(const weak_ptr&amp; other)    {        reset();        ptr_ = other.ptr_;        counter_ = other.counter_;        if (counter_)            ++counter_-&gt;weaks;        return *this;    }    // 移动赋值操作符    weak_ptr&amp; operator=(weak_ptr&amp;&amp; other) noexcept    {        reset();        ptr_ = other.ptr_;        counter_ = other.counter_;        other.ptr_ = nullptr;        other.counter_ = nullptr;        return *this;    }    // 从shared_ptr赋值    weak_ptr&amp; operator=(const shared_ptr&lt;T&gt;&amp; other)    {        reset();        ptr_ = other.ptr_;        counter_ = other.counter_;        if (counter_)            ++counter_-&gt;weaks;        return *this;    }    // 析构函数    ~weak_ptr()    {        reset();    }    // 重置weak_ptr    void reset()    {        if (counter_) {            // 断开与对象的关联            if (counter_-&gt;uses == 0 &amp;&amp; --counter_-&gt;weaks == 0) {                  delete counter_;                counter_ = nullptr;            }        }    }    // 获取指向对象的shared_ptr，如果对象已销毁，则返回空shared_ptr    shared_ptr&lt;T&gt; lock() const    {        if (!counter_ || counter_-&gt;uses == 0)            return shared_ptr&lt;T&gt;();        // 这样创建的shared_ptr将增加对象的强引用计数        return shared_ptr&lt;T&gt;(*this);    }    // 检查weak_ptr是否有效（即是否可以成功lock）    bool expired() const {         return !counter_ || counter_-&gt;uses == 0;     }private:    T* ptr_ = nullptr;    Counter* counter_ = nullptr;    friend class shared_ptr&lt;T&gt;;};struct TestObject {    int value;    TestObject(int v) : value(v) {}    ~TestObject() { std::cout &lt;&lt; "Object with value " &lt;&lt; value &lt;&lt; " destroyed.\n"; }};int main() {    // 创建一个TestObject实例，并用shared_ptr管理    shared_ptr&lt;TestObject&gt; sptr(new TestObject(42));    // 输出强引用计数    std::cout &lt;&lt; "Initial use_count: " &lt;&lt; sptr.use_count() &lt;&lt; "\n";        shared_ptr&lt;TestObject&gt; sptr2 = sptr;    std::cout &lt;&lt; "Initial use_count: " &lt;&lt; sptr.use_count() &lt;&lt; "\n";    // 从sptr构造一个weak_ptr    weak_ptr&lt;TestObject&gt; wptr(sptr);    // 输出强引用计数    std::cout &lt;&lt; "After creating weak_ptr, use_count: " &lt;&lt; sptr.use_count() &lt;&lt; "\n";    // 检查wptr是否过期    if (wptr.expired()) {        std::cout &lt;&lt; "Weak pointer is already expired.\n";    } else {        std::cout &lt;&lt; "Weak pointer is not expired.\n";    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合优化</title>
      <link href="/suan-fa/zu-he-you-hua/"/>
      <url>/suan-fa/zu-he-you-hua/</url>
      
        <content type="html"><![CDATA[<center><h1> 组合优化  </h1></center> <h2 id="一-问题与算法"><a href="#一-问题与算法" class="headerlink" title="一 问题与算法"></a>一 问题与算法</h2><h3 id="1-1-两个问题（引出算法需要关注的地方）"><a href="#1-1-两个问题（引出算法需要关注的地方）" class="headerlink" title="1.1 两个问题（引出算法需要关注的地方）"></a>1.1 两个问题（引出算法需要关注的地方）</h3><h4 id="1-1-1-旅行售货商问题（最优Hamilton圈）"><a href="#1-1-1-旅行售货商问题（最优Hamilton圈）" class="headerlink" title="1.1.1 旅行售货商问题（最优Hamilton圈）"></a>1.1.1 旅行售货商问题（最优Hamilton圈）</h4><p>问题：直升飞机遍历 n 个钻井平台并返回所需的最短距离，（汉密尔顿环游）。</p><p>能确保正确的解法：属于NP完全类问题（陈佬的目标），暴力为 $(n-1)!$ ，太慢了</p><p>近似解：最近邻算法（Nearest Neighbor Algorithm)，每次选则最近且未被访问过的点。缺点是会遗漏某点导致后面某次需要花费较大距离来访问这个被遗漏的点。</p><h4 id="1-1-2-欧氏匹配问题"><a href="#1-1-2-欧氏匹配问题" class="headerlink" title="1.1.2 欧氏匹配问题"></a>1.1.2 欧氏匹配问题</h4><p>类似一笔画问题（欧拉环游）</p><p>问题：当画电路图时，抬笔与落笔会浪费大量时间，因此要最小化抬笔时间。</p><p>提到的性质：</p><p>（1）图中总存在偶数个奇度点</p><p>（2）存在欧拉回路 $ \Longleftrightarrow $ 连通且无奇度点</p><p>解法：新添加边，使奇度点边偶度点。</p><p>设新添加边为 $p→q$，其距离为 $t(p,q)$，那么总有 $t(p,q) \le t(p,r)+t(r,q)$。然后求处所有这样的边，并且这些边的长度总和最小。</p><p>如果最初的图不连通，通过添加边得到无奇度点的图，这种情况抬笔是必须的。特殊的，当一条边都没有的时候该问题转化为旅行售货商问题。</p><h3 id="1-2-度量运行时间"><a href="#1-2-度量运行时间" class="headerlink" title="1.2 度量运行时间"></a>1.2 度量运行时间</h3><p>即算法的时间复杂度</p><p>多项式级复杂度（polynomial time）：表示复杂度为 $n^c$ ,而 $(n!)\ 和\ x^n$ 就不是。</p><p><a href="http://www.matrix67.com/blog/archives/105">四种问题</a></p><p>$P$ 问题：可以找到一个能在多项式的时间里解决它的算法的问题。</p><p>$NP$ 问题：可以在多项式的时间里验证一个解的问题，另一个定义是，可以在多项式的时间里猜出一个解的问题。</p><p>归约即可约化：“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。</p><p>$NPC$ 问题：它是一个NP问题而且所有的NP问题都可以约化到它。</p><p>$NP-Hard$ ：能被所有的NP问题都约化。</p><h3 id="1-3-习题"><a href="#1-3-习题" class="headerlink" title="1.3 习题"></a>1.3 习题</h3><p>（1）证明对 n 个点的欧氏旅行售货商有 $(n-1)!/2$ 种不同的环游。</p><p>证明：n 个点有 n-1 条无向边，先选取点 $p_1$，它有 n-1 个点可选，假设又选了 $p_2$ 后面又 n-2 个点可选，一直选到 $p_{n-1}$,此时只有一个选择即 $p_n$，由乘法原理，再考虑到边是无向的，所以有 $(n-1)!/2$ 种不同的方法。</p><p>例：n=3，点为A、B、C，则方法为A→B→C→A，恰好是一个环，所以它的解只有一种即这个环。</p><p>（2）假定有一台能够对旅行售货商问题的估计可行解的十亿分之一秒的计算机，如果我们测试所有可能的解，在24小时的计算机时间内我们能够解决一个多大规模的问题？如果我们有一台比它块十倍的计算机，规模能增加多少，快一百倍吗？</p><p>解：十亿分之一秒 = $10^{-9}s$ ，$13!\approx 6×10^{9}$，所以仅能解决 n=14 左右的问题，当速度变为 $10^{-10}$ 时，规模无法增加100倍，只能增加 1+n/10 倍。</p><h2 id="二-最优树和最优路"><a href="#二-最优树和最优路" class="headerlink" title="二 最优树和最优路"></a>二 最优树和最优路</h2><h3 id="2-1-图的一些约定写法"><a href="#2-1-图的一些约定写法" class="headerlink" title="2.1 图的一些约定写法"></a>2.1 图的一些约定写法</h3><p>(1) $G=(V,E) \ \ \  表示\ G\ 有顶点集\ V\ 和边集\ E$</p><p>(2) $e=uv$  表示$e$ 的端点是 $u$ 和 $v$</p><p>(3) $\ G\ 的子图\ H\ 满足\ \ V(H)\subseteq  V(G),\ E(H) \subseteq E(G),并且每个\ e\in E(H)$ </p><p>(4) 对于 $A\subseteq E$ ,$G\setminus A$ 表示 $G$ 删除 $A$ 后得到的子图 $H$ </p><p>(5) 对于 $a\in V\ or\ E$, $G\setminus {a}$ 为 $G$ 删除了一个点或一条边</p><p>(6) $v\in V$, $G$ 是连通的 $G\setminus v$ 是不连通的，那么称顶点 $v$ 是 $G$ 的一个割点</p><h3 id="2-2-最小生成树（MST）"><a href="#2-2-最小生成树（MST）" class="headerlink" title="2.2 最小生成树（MST）"></a>2.2 最小生成树（MST）</h3><h4 id="2-2-1-MST-的两种算法"><a href="#2-2-1-MST-的两种算法" class="headerlink" title="2.2.1 MST 的两种算法"></a>2.2.1 MST 的两种算法</h4><p>(1) $Kruskal$ 算法：每次添加这样的边，这条边的端点在图中不连通的情况下保证费用最小（加边，时间复杂度$O(nm)$）</p><p>(2) $Prim$ 算法：选取不在树中的点加入树，这个点要保证加入树的费用最小（加点，时间复杂度$O(n^2)$）</p><h4 id="2-2-2-MST和线性规划"><a href="#2-2-2-MST和线性规划" class="headerlink" title="2.2.2 MST和线性规划"></a>2.2.2 MST和线性规划</h4><p>定理2.8：设 $x^0 是关于费用\ c_e\ 的一个MST的特征向量，那么\ x^0 是\ min\ c^Tx\ 的最优解$ </p><p>证明：考虑问题：</p><script type="math/tex; mode=display">min\ c^Tx \\s.t.\ \ \ \ （代表受限于一下条件）\\x(A)\le |V|-k(A)，对所有\ A\subset E\\x(E)=|V|-1\\x_e\ge0,对所有\ e\in E</script><p>算了，先跳过</p><h4 id="2-2-3-习题"><a href="#2-2-3-习题" class="headerlink" title="2.2.3 习题"></a>2.2.3 习题</h4><p>证明：G 的一个连通生成子图是生成树当且仅当它恰好有 n-1 条边</p><h3 id="2-3-最短路"><a href="#2-3-最短路" class="headerlink" title="2.3 最短路"></a>2.3 最短路</h3><h4 id="2-3-1-提出最短路问题"><a href="#2-3-1-提出最短路问题" class="headerlink" title="2.3.1 提出最短路问题"></a>2.3.1 提出最短路问题</h4><p>条件：给定有向图 $G$ ，顶点 $r\in V$ ，以及实费用向量 $(c_e:e \in E).$ </p><p>目标：对每个 $v\in V$，找到一条从 $r$ 到 $v$ 的最小费用有向路</p><p>解决最短路问题的基础：</p><p>  假设对每个 $v\in V$ 存在一条费用为 $y_v$ 的从 $r$ 到 $v$ 的有向路，并且还有一条满足$y_v+c_{vw}&lt; y_w$ 的弧 $vw\in E$ ，所以存在一条到 $w$ 的通过 $vw$ 的费用为 $y_v+c_{vw}$ 的更便宜的有向路。</p><p>  特别的，如果说 $y_v,\ v\in V$ 是到 v 的有向路的最小费用，那么 y 满足</p><script type="math/tex; mode=display">y_v+c_{vw}\ge y_w , \ \ 对所有\ vw\in E  \tag a</script><p> 我们称 $y=(y_v:v\in V)$ 是一个可行势(我理解为 y 是一个最短路解)。</p><h4 id="2-3-2-Ford-算法"><a href="#2-3-2-Ford-算法" class="headerlink" title="2.3.2 Ford 算法"></a>2.3.2 Ford 算法</h4><p>可以判断是否存在负环。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化 y ，pwhile y 还不是一个可行势：找到一条不正确的弧并纠正它-----------------------------------设 r 为源点，然后依次枚举其他点       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改进后的Bellman-Ford算法，用队列,算法复杂度 $O(nm)$ , n 是点的个数，m 是边的条数</p><p>在无圈有向图中用拓扑排序（topological sort）求最短路，算法复杂度 $O(n+m)$ ：先找到图G的拓扑排序，然后动态规划。</p><p>没有负权时用 $Dijkstra$ 算法，复杂度 $O(m·logn)$ ,</p><h4 id="2-3-3-习题"><a href="#2-3-3-习题" class="headerlink" title="2.3.3 习题"></a>2.3.3 习题</h4><p>1、举例说明：</p><p>（1）一棵以 $r$ 为根的有向生成树可以是最小费用的但不包含 $r$ 到所有顶点的最小费用有向路。</p><p>（2）一棵以 $r$ 为根的有向生成树可以是包含所有顶点的最小费用有向路的但不是最小费用的。</p><p>解：空</p><p>2、举例说明：如果存在负费用的有向环，那么最短简单有向路的子路不必是最短简单有向路。</p><p>解：走一次负环</p><h2 id="三-最大流问题"><a href="#三-最大流问题" class="headerlink" title="三 最大流问题"></a>三 最大流问题</h2><h3 id="3-1-网络流问题"><a href="#3-1-网络流问题" class="headerlink" title="3.1 网络流问题"></a>3.1 网络流问题</h3><p>网络流问题类似于这个：多个工厂给多个商店送货问题。想想就 $complex$ 。</p><p>最大流问题是网络流一个重要的子问题。</p><p>判定最小费用流问题是否有可行解的问题等价于最大流问题。</p><p>最短路是最小费用流问题的一个子类，我们可以通过解决最短路问题测试给定的可行解是否是最优的。</p><h3 id="3-2-最大流问题"><a href="#3-2-最大流问题" class="headerlink" title="3.2 最大流问题"></a>3.2 最大流问题</h3><h2 id="四-最小费用流问题"><a href="#四-最小费用流问题" class="headerlink" title="四 最小费用流问题"></a>四 最小费用流问题</h2><h2 id="五-最优匹配"><a href="#五-最优匹配" class="headerlink" title="五 最优匹配"></a>五 最优匹配</h2><h2 id="六-多面体整性"><a href="#六-多面体整性" class="headerlink" title="六 多面体整性"></a>六 多面体整性</h2><h2 id="七-旅行售货问题"><a href="#七-旅行售货问题" class="headerlink" title="七 旅行售货问题"></a>七 旅行售货问题</h2><h2 id="八-拟阵"><a href="#八-拟阵" class="headerlink" title="八 拟阵"></a>八 拟阵</h2><h2 id="九-NP-和-NP-完全性"><a href="#九-NP-和-NP-完全性" class="headerlink" title="九 NP 和 NP- 完全性"></a>九 NP 和 NP- 完全性</h2><h2 id="附录-线性规划"><a href="#附录-线性规划" class="headerlink" title="附录 线性规划"></a>附录 线性规划</h2><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1 目的"></a>1 目的</h3><p>线性规划(liner programming, LP)所关注的问题是：</p><p>​    寻找使给定线性函数 $c^Tx$ 最大化向量 x，其中 x 取遍所有满足给定线性不等式组 $Ax\le b$ 的向量中，我们想要找出具有最大值 $c^Tx$ 的一个。标准形式为：</p><script type="math/tex; mode=display">max\ \ c^Tx\\s.t.\\Ax\le b</script><p>松弛形式：</p><script type="math/tex; mode=display">max\ \ \  z=\sum c_ix_i\\s.t.\ \left\{\begin{matrix} \ \sum a_{ij}x_j=b_j \\ \ \ \ \ \ \ \ \ \ \  x_j\ge 0\end{matrix}\right.</script><p>​    以高中数学举例解释抽象的上段：</p><p>某工厂在计划期内要安排生产 Ⅰ， Ⅱ 两种产品，利润分别为2元和3元，生产一件 Ⅰ 需要占用一台设备和原料A 4kg，生产一件 Ⅱ 需要占用两台设备和原料 B 4kg，目前有 8 台设备，16kg原料A，12kg原料B。问如何安排生产使工厂获利最多？</p><p>设生产 x~1~ 件 Ⅰ，生产 x~2~ 件 Ⅱ，则可以把问题写成： Ⅰ </p><script type="math/tex; mode=display">max\ \  2x_1 + 3x_2 \\s.t.\\x_1+2x_2\le 8\\4x_1\le 16\\4x_2\le 12\\x_1,x_2\ge 0</script><p>s.t.代表subject to，意思是受限于，受下面的条件限制。</p><p>上式的 $c^Tx$ 中的 c^T^ 代表矩阵 [2,3]^T^，x 代表矩阵 [x^1^, x^2^]。</p><p>$Ax\le b$ 中 A 代表矩阵$\begin{bmatrix}<br>  1&amp;2 \\<br>  4&amp;0 \\<br>  0&amp;4 \\ -1&amp;0\\ 0&amp;-1<br>\end{bmatrix}$，b 代表矩阵$\begin{bmatrix}<br>  8 \\<br>  6 \\<br>  12 \\0\\0<br>\end{bmatrix}$。</p><h3 id="2-单纯形法"><a href="#2-单纯形法" class="headerlink" title="2 单纯形法"></a>2 单纯形法</h3><p>单纯形法(simplex method)：先找出可行域的一个顶点，据一定规则判断其是否最优；若否，则转换到与之相邻的另一顶点，并使目标函数值更优；如此下去，直到找到某最优解为止。</p><p>用单纯形法求解安排生产问题：</p><p>引入松弛变量 x~3~，x~4~，x~5~ 化标准型：</p><script type="math/tex; mode=display">max\ \ z=2x_1+3x_2\\s.t.\ \left\{\begin{matrix} \ \ \ x_1+x_2+x_3\ \ \ \ \ \ \ \ \ &= 8 \\ 4x_1\ \ \ \ \ \ \ \ \ \ \ \ \ \ +x_4 &= 16\\ \ \ \ \ 4x_2\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  +x_5 &= 12\\ x_1,x_2,x_3,x_4,x_5 &\ge 0\end{matrix}\right.</script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/c/she-ji-mo-shi/"/>
      <url>/c/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#一-设计模式原则">一 设计模式原则</a><ul><li><a href="#10-单一职责原则">1.0 单一职责原则</a></li><li><a href="#11-开闭原则">1.1 开闭原则</a></li><li><a href="#12-里氏替换原则">1.2 里氏替换原则</a></li><li><a href="#13-接口隔离原则">1.3 接口隔离原则</a></li><li><a href="#14-依赖倒置原则">1.4 依赖倒置原则</a></li></ul></li><li><a href="#二-创建者模式">二 创建者模式</a><ul><li><a href="#1-单例模式">1 单例模式</a></li><li><a href="#2-简单工厂模式">2 简单工厂模式</a></li><li><a href="#4-工厂模式">4 工厂模式</a></li><li><a href="#5-抽象工厂模式">5 抽象工厂模式</a></li><li><a href="#武器枪速射炮激光">|武器    |枪    |速射炮    |激光|</a></li><li><a href="#6-生成器建造者模式">6 生成器/建造者模式</a></li></ul></li><li><a href="#三-结构型模式">三 结构型模式</a><ul><li><a href="#1-适配器模式">1 适配器模式</a></li><li><a href="#2-桥接模式">2 桥接模式</a></li><li><a href="#3-组合模式">3 组合模式</a></li><li><a href="#4-装饰器模式">4 装饰器模式</a></li><li><a href="#5-外观模式">5 外观模式</a></li><li><a href="#6-享元模式">6 享元模式</a></li><li><a href="#7-代理模式">7 代理模式</a></li></ul></li><li><a href="#四-行为模式">四 行为模式</a><ul><li><a href="#1-策略模式">1 策略模式</a></li><li><a href="#2-责任链模式">2 责任链模式</a></li><li><a href="#3-迭代器模式">3 迭代器模式</a></li><li><a href="#4-中介者模式">4 中介者模式</a></li><li><a href="#5-备忘录模式">5 备忘录模式</a></li><li><a href="#6-观察者模式">6 观察者模式</a></li><li><a href="#7-状态模式">7 状态模式</a></li><li><a href="#８-命令模式">８ 命令模式</a></li><li><a href="#9-模板方法模式">9 模板方法模式</a></li><li><a href="#10-访问者模式">10 访问者模式</a></li></ul></li></ul><h1 id="一-设计模式原则"><a href="#一-设计模式原则" class="headerlink" title="一 设计模式原则"></a>一 设计模式原则</h1><h2 id="1-0-单一职责原则"><a href="#1-0-单一职责原则" class="headerlink" title="1.0 单一职责原则"></a>1.0 单一职责原则</h2><h2 id="1-1-开闭原则"><a href="#1-1-开闭原则" class="headerlink" title="1.1 开闭原则"></a>1.1 开闭原则</h2><p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。在不修改现有代码的情况下，应该通过添加新功能来扩展系统。</p><h2 id="1-2-里氏替换原则"><a href="#1-2-里氏替换原则" class="headerlink" title="1.2 里氏替换原则"></a>1.2 里氏替换原则</h2><p>子类型必须能够替换其基类型而不影响程序的正确性。</p><h2 id="1-3-接口隔离原则"><a href="#1-3-接口隔离原则" class="headerlink" title="1.3 接口隔离原则"></a>1.3 接口隔离原则</h2><p>不应该强迫客户端依赖于它们不使用的接口。一个类不应该被迫实现它用不到的接口。</p><h2 id="1-4-依赖倒置原则"><a href="#1-4-依赖倒置原则" class="headerlink" title="1.4 依赖倒置原则"></a>1.4 依赖倒置原则</h2><p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li><p>高层和底层没有直接关系</p></li><li><p>高层模块不依赖于低层模块： 高层模块和低层模块都应该依赖于抽象。换句话说，模块之间的依赖关系应该建立在接口或抽象类上，而不是具体实现上。</p></li><li><p>抽象不依赖于具体实现： 接口或抽象类应该定义高层模块所需的方法和属性，而不应该包含对具体实现的引用。具体实现应该依赖于抽象而不是反过来。</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 高层模块, 依赖于抽象，不依赖于底层模块class Switch {public:    void TurnOn(Device* device)   device-&gt;TurnOn();    void TurnOff(Device* device)  device-&gt;TurnOff();};// 低层模块也依赖于抽象class Lamp : public Device {public:    void TurnOn() override {}  // 具体实现    void TurnOff() override {} // 具体实现};// 低层模块class Fan : public Device {public:    void TurnOn() override {} // 具体实现     void TurnOff() override {} // 具体实现};// 抽象class Device {public:    virtual void TurnOn() = 0;    virtual void TurnOff() = 0;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-创建者模式"><a href="#二-创建者模式" class="headerlink" title="二 创建者模式"></a>二 创建者模式</h1><p>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1 单例模式"></a>1 单例模式</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>将一个类可以实例化多个对象的路堵死：</strong></p><ul><li>构造函数私有化，在类内部只调用一次</li><li>拷贝构造函数私有化或者禁用（使用 = delete）</li><li>拷贝赋值操作符重载函数私有化或者禁用<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 定义一个单例模式的类class Singleton{public:    // = delete 代表函数禁用, 也可以将其访问权限设置为私有    Singleton(const Singleton&amp; obj) = delete;    Singleton&amp; operator=(const Singleton&amp; obj) = delete;    static Singleton* getInstance();private:    Singleton() = default;    static Singleton* m_obj;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>饿汉模式：</strong></p><p>饿汉模式就是在类加载的时候立刻进行实例化</p><p><strong>懒汉模式：</strong></p><p>懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化。</p><p>有线程安全问题。可以使用双重检查锁定或静态局部对象。</p><h2 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2 简单工厂模式"></a>2 简单工厂模式</h2><p>定义一个用于创建对象的接口，但将对象的类型交给子类决定。</p><p>一个工厂类，多个商品类，通过传入工厂类的参数，返回商品类对象。</p><p><strong>缺点</strong>：想要生成更多产品，那么就需要修改工厂类，违反开闭原则。 而工厂模式不会，想生成更多产品的话，直接新增工厂类和商品类。</p><h2 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4 工厂模式"></a>4 工厂模式</h2><p>简单工厂模式只有一个工厂类，而工厂模式是有很多的工厂类。<br>想要更多商品，只需要增加类即可。<br>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化<strong>推迟</strong>到子类。使用虚函数实现。</p><ul><li>一个工厂基类：包含一个虚工厂函数，用于实现多态</li><li>多个工厂子类：重写父类的工厂函数，创建该子类生产的对应类对象</li><li>如下，基类为 Factory 子类为 ConcreteFactoryA 和 ConcreteFactoryB</li><li>一个商品基类： Product</li><li>多个商品子类： ConcreteProductA 和 ConcreteProductB</li><li>使用时只需要<ul><li>Factory factory = new ConcreteFactoryA();</li><li>Product product = factory.create();  // 创建商品类，由于虚函数原因，执行的实际上是 ConcreteFactoryA 的 create</li><li>product-&gt;create();</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Product {public:    virtual void create() = 0;};class ConcreteProductA : public Product {public:    void create() override {        // 具体产品 A 的创建实现    }};class ConcreteProductB : public Product {public:    void create() override {        // 具体产品 B 的创建实现    }};class Factory {public:    virtual Product* createProduct() = 0;};class ConcreteFactoryA : public Factory {public:    Product* createProduct() override {        return new ConcreteProductA();    }};class ConcreteFactoryB : public Factory {public:    Product* createProduct() override {        return new ConcreteProductB();    }};// 在程序的其他地方：Factory* factory = new ConcreteFactoryA();Product* product = factory-&gt;createProduct();product-&gt;create();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-抽象工厂模式"><a href="#5-抽象工厂模式" class="headerlink" title="5 抽象工厂模式"></a>5 抽象工厂模式</h2><p> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p> 工厂类生产的产品类是可变的。</p><p> 工厂类的职责是创建一组相关的产品，说明产品类可以有多个具体子类。</p><p><strong>造船工厂：</strong><br>||基础型|    标准型    |旗舰型|<br>|——|—-|———-|———-|<br>|船体    |木头    |钢铁    |合成金属|<br>|动力    |手动    |内燃机    |核能|</p><h2 id="武器-枪-速射炮-激光"><a href="#武器-枪-速射炮-激光" class="headerlink" title="|武器    |枪    |速射炮    |激光|"></a>|武器    |枪    |速射炮    |激光|</h2><p>需要一个基类工厂</p><p>需要三个工厂类生产三种类型的船</p><p>需要一个基类产品</p><p>需要三个产品类代表三种类型的船</p><p>需要三个属性类代表三种属性，船体，动力，武器</p><p>每个属性需要三个部件类代表不同的部件</p><p>最终生产的商品船。有可变属性。</p><h2 id="6-生成器-建造者模式"><a href="#6-生成器-建造者模式" class="headerlink" title="6 生成器/建造者模式"></a>6 生成器/建造者模式</h2><p>分布构建复杂的对象。</p><p> 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p><h1 id="三-结构型模式"><a href="#三-结构型模式" class="headerlink" title="三 结构型模式"></a>三 结构型模式</h1><p>如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p><h2 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1 适配器模式"></a>1 适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>优势：</strong>  </p><ul><li>适配器模式使得不兼容的接口能够协同工作，提高了代码的复用性和灵活性。</li><li>允许在不修改现有代码的情况下使用已存在的类。<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># 目标接口class ChineseSocket:    def charge(self):        pass# 被适配对象class BritishPlug:    def power_supply(self):        print("Supplying power with British plug")# 适配器class Adapter(ChineseSocket):    def __init__(self, british_plug):        self.british_plug = british_plug    def charge(self):        print("Adapter is converting...")        self.british_plug.power_supply()# 客户端代码british_plug = BritishPlug()adapter = Adapter(british_plug)adapter.charge()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2 桥接模式"></a>2 桥接模式</h2><h2 id="3-组合模式"><a href="#3-组合模式" class="headerlink" title="3 组合模式"></a>3 组合模式</h2><h2 id="4-装饰器模式"><a href="#4-装饰器模式" class="headerlink" title="4 装饰器模式"></a>4 装饰器模式</h2><p>允许你通过将对象放入包装对象中来动态地为对象添加新的行为。</p><p>它是一种替代继承的方式，可以在不修改现有代码的情况下，扩展对象的功能。</p><p>Coffee 是组件接口，SimpleCoffee 是具体组件，CoffeeDecorator 是装饰器。MilkDecorator 和 SugarDecorator 是具体装饰器，通过组合不同的装饰器，我们可以动态地改变咖啡的成本。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 组件接口class Coffee {public:    virtual int cost() const = 0;};// 具体组件class SimpleCoffee : public Coffee {public:    int cost() const override {        return 5;    }};// 装饰器class CoffeeDecorator : public Coffee {protected:    Coffee* coffee;public:    CoffeeDecorator(Coffee* coffee) : coffee(coffee) {}    int cost() const override {        return coffee-&gt;cost();    }};// 具体装饰器 - 牛奶class MilkDecorator : public CoffeeDecorator {public:    MilkDecorator(Coffee* coffee) : CoffeeDecorator(coffee) {}    int cost() const override {        return CoffeeDecorator::cost() + 2;    }};// 具体装饰器 - 糖class SugarDecorator : public CoffeeDecorator {public:    SugarDecorator(Coffee* coffee) : CoffeeDecorator(coffee) {}    int cost() const override {        return CoffeeDecorator::cost() + 1;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-外观模式"><a href="#5-外观模式" class="headerlink" title="5 外观模式"></a>5 外观模式</h2><h2 id="6-享元模式"><a href="#6-享元模式" class="headerlink" title="6 享元模式"></a>6 享元模式</h2><h2 id="7-代理模式"><a href="#7-代理模式" class="headerlink" title="7 代理模式"></a>7 代理模式</h2><p>为其他对象提供一种代理以控制对这个对象的访问。</p><h1 id="四-行为模式"><a href="#四-行为模式" class="headerlink" title="四 行为模式"></a>四 行为模式</h1><p>负责对象间的高效沟通和职责委派。</p><h2 id="1-策略模式"><a href="#1-策略模式" class="headerlink" title="1 策略模式"></a>1 策略模式</h2><p>定义和背景：</p><p>“策略模式是一种行为设计模式，它允许定义一组算法，将每个算法封装起来，并使它们可以相互替换，使算法的变化独立于使用算法的客户端。这种模式属于行为型设计模式，通过将算法与客户端代码解耦，提高了代码的可维护性和扩展性。”<br>主要组成部分：</p><p>“策略模式主要由三个组成部分组成：策略接口、具体策略类和环境类。”<br>“策略接口定义了一组算法的通用接口，通常包含一个执行算法的方法。”<br>“具体策略类实现了策略接口，提供了具体的算法实现。可以有多个具体策略类，每个代表不同的算法。”<br>“环境类包含一个对策略接口的引用，并且可以在运行时切换不同的具体策略对象，使得客户端可以选择不同的算法执行。”<br>例子：</p><p>“让我用一个简单的例子来说明策略模式。假设我们有一个购物车应用，用户可以选择不同的支付方式。我们可以使用策略模式来实现这个功能。支付方式（例如信用卡支付、PayPal支付）就是具体的策略，而购物车是环境类，用户可以在购物过程中切换支付方式，而不影响购物车的其他部分。”<br>优点：</p><p>“策略模式的优点包括：”<br>“算法的独立性：客户端代码与具体算法实现解耦，使得算法可以独立变化，不影响客户端。”<br>“易于扩展：可以方便地添加新的具体策略类，扩展系统的功能。”<br>“避免使用多重条件语句：避免了使用多个 if-else 或 switch 语句，提高了代码的可读性和可维护性。”<br>应用场景：</p><p>“策略模式适用于以下场景：”<br>“当一个类有多个行为，而且这些行为在运行时可互换时。”<br>“当一个系统需要动态地在几种算法中选择一种。”<br>“当一个对象需要完成的任务可以有不同的变体，并且这些变体可以通过定义不同的策略来实现。”</p><h2 id="2-责任链模式"><a href="#2-责任链模式" class="headerlink" title="2 责任链模式"></a>2 责任链模式</h2><h2 id="3-迭代器模式"><a href="#3-迭代器模式" class="headerlink" title="3 迭代器模式"></a>3 迭代器模式</h2><h2 id="4-中介者模式"><a href="#4-中介者模式" class="headerlink" title="4 中介者模式"></a>4 中介者模式</h2><h2 id="5-备忘录模式"><a href="#5-备忘录模式" class="headerlink" title="5 备忘录模式"></a>5 备忘录模式</h2><h2 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6 观察者模式"></a>6 观察者模式</h2><p>定义了对象之间的一对多依赖关系，使得当一个对象改变状态，所有依赖它的对象都会得到通知并被自动更新。</p><ul><li>推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。</li><li>拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。</li></ul><h2 id="7-状态模式"><a href="#7-状态模式" class="headerlink" title="7 状态模式"></a>7 状态模式</h2><h2 id="８-命令模式"><a href="#８-命令模式" class="headerlink" title="８ 命令模式"></a>８ 命令模式</h2><h2 id="9-模板方法模式"><a href="#9-模板方法模式" class="headerlink" title="9 模板方法模式"></a>9 模板方法模式</h2><h2 id="10-访问者模式"><a href="#10-访问者模式" class="headerlink" title="10 访问者模式"></a>10 访问者模式</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文字识别</title>
      <link href="/shen-du-xue-xi/wen-zi-shi-bie/"/>
      <url>/shen-du-xue-xi/wen-zi-shi-bie/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="基于CRNN的文字识别实战"><a href="#基于CRNN的文字识别实战" class="headerlink" title="基于CRNN的文字识别实战"></a>基于CRNN的文字识别实战</h1><h2 id="1-RNN"><a href="#1-RNN" class="headerlink" title="1.RNN"></a>1.RNN</h2><p>循环神经网络 （Recurrent Neural Network，RNN）</p><p>​    是一种用于处理序列数据的神经网络。相比一般的神经网络来说，他能够处理序列变化的数据。比如某个单词的意思会因为上文提到的内容不同而有不同的含义，RNN就能够很好地解决这类问题。</p><h2 id="2-LSTM"><a href="#2-LSTM" class="headerlink" title="2.LSTM"></a>2.LSTM</h2><p>长短期记忆（Long short-term memory, LSTM）</p><p>​    是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p><h2 id="3-seq2seq"><a href="#3-seq2seq" class="headerlink" title="3.seq2seq"></a>3.seq2seq</h2><h2 id="4-endoder-encoder模型"><a href="#4-endoder-encoder模型" class="headerlink" title="4.endoder-encoder模型"></a>4.endoder-encoder模型</h2><p>encoder-decoder模型，又叫做编码-解码模型。这是一种应用于seq2seq问题的模型。</p><p>编码，就是将输入序列转化成一个固定长度的向量；</p><p>解码，就是将之前生成的固定向量再转化成输出序列。</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112061104960.png" alt="image-20211206110435820"></p><h2 id="5-dropout"><a href="#5-dropout" class="headerlink" title="5.dropout"></a>5.dropout</h2><p><a href="https://blog.csdn.net/program_developer/article/details/80737724">dropout</a> </p><p>解决过拟合问题</p><p>Dropout可以作为训练深度神经网络的一种trick供选择。在每个训练批次中，通过忽略一半的特征检测器（让一半的隐层节点值为0），可以明显地减少过拟合现象。这种方式可以减少特征检测器（隐层节点）间的相互作用，检测器相互作用是指某些检测器依赖其他检测器才能发挥作用。</p><p>Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征，如图1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112061110071.png" alt="image-20211206111034825"></p><p>6.独热编码 One-Hot</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-进阶</title>
      <link href="/suan-fa/suan-fa-bi-ji-jin-jie/"/>
      <url>/suan-fa/suan-fa-bi-ji-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-网络流"><a href="#第一章-网络流" class="headerlink" title="第一章 网络流"></a>第一章 网络流</h2><h3 id="1-网络流相关概念"><a href="#1-网络流相关概念" class="headerlink" title="1 网络流相关概念"></a>1 网络流相关概念</h3><p>==流网络==：</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111181457502.jpeg" alt="网络流"> </p><ul><li>s: 源点</li><li>t：汇点</li><li>容量：边 $uv$ 能通过的最大流量，c(u,v)</li><li>流量：边 $uv$ 实际通过的流量，f(u,v)</li></ul><p>==可行流 f== (feasible flow 不考虑反向边)</p><ol><li><p>须满足容量限制： $0\le f(u,v)\le c(u,v)$;</p></li><li><p>流量守恒,对除s、t以外的点，流入等于流出： $\forall_x \in V\setminus s\ and\ t, \sum \limits_{(v,x)\in E}f(v,x)=\sum \limits_{(x,v)\in E}f(x,v)$ </p></li></ol><p>==净流量==：从源点流入的总流量，$|f|= \sum  \limits_{(s,v)\in E} f(s,v)-\sum \limits_{(v,s)\in E} f(v,s) $  </p><p>==最大流==：流量值最大的可行流，<strong>最大可行流</strong>(Maximum Flow)。</p><p>==残留网络 G~f~==：对流网络的某一条可行流来说,残留网络包括以下：</p><ul><li><p>点和边：$V_f=V,E_f=E\ and\ E的反向边 $</p></li><li><p>原始边的流量：$c’(u,v) =c(u,v)-f(u,v),\ \ (u,v)\in E $ </p></li><li>反向边的流量：$c’(v,u)=f(u,v),\ \ (v,u)\in E$  </li></ul><blockquote><p><strong>定理</strong>：若f是原网络G的可行流，f’是G~f~的可行流，则f+f’是原流网络G的一个可行流。</p><p>证明：</p><ol><li>容量限制：<ul><li>对于正向边$f(u,v)$: $0\le f’(u,v)\le c’(u,v)=c(u,v)-f(u,v)$ ,然后经过移项可证</li><li>对于反向边$f’(u,v)$: $0\le f’(u,v)\le c’(u,v)= f(v,u)=c(u,v)$, 所以 $f(v,u)-f’(u,v) \ge 0$ 且 $\le c(u,v)$ 得证</li></ul></li><li>流量守恒：<ul><li>$|f+f’|=|f|+|f’|$   </li></ul></li></ol></blockquote><p>==增广路径==(augmenting path)：在残留网络沿着容量大于零的边走能到达汇点的路径。</p><blockquote><p><strong>定理</strong>：若G~f~不存在增广路径/可行流，则 f 为 G 的最大流。</p><p>证明在<a href="#max-flow min-cut theorem">最大流最小割定理</a></p></blockquote><p>==割==(cut)：把点集 V 分成两部分 S 和 T，($S\cup T=V\ 且 \ S\cap T=\emptyset $)，源点 $s\in S$,汇点 $t\in T$ ,划分的结果就是一个割，记作 $CUT(S,T)$，共有 2^n-2^ 种划分方式。</p><ul><li><p><strong>割边</strong>：如果一条弧的两个顶点一个属于顶点集S一个属于顶点集T，该弧为割 $CUT(S,T)$ 的一条割边</p></li><li><p><strong>正向割边</strong>：从集合 S 指向集合 T 的割边</p></li><li><p><strong>逆向割边</strong>：从集合 T 指向集合 S 的割边</p></li><li><p><strong>割的容量</strong>：所有正向割边的流量之和，$c(S,T)=\sum \limits_{u\in S} \sum \limits_{v\in T} c(u,v)$ </p></li><li><p><strong>割的流量</strong>：所正向割边的流量和减所有逆向割边的流量和，$f(S,T)=\sum \limits_{u \in S} \sum \limits_{v\in T}f(u,v)-\sum \limits_{u \in S} \sum \limits_{v\in T}f(v,u)$ </p><blockquote><p>定理：对任意一个割，$f(S,T)\le c(S,T)$ </p><p>证明：利用放缩，$f(S,T)\le \sum \limits_{u \in S} \sum \limits_{v\in T}f(u,v)\le \sum \limits_{u\in S} \sum \limits_{v\in T} c(u,v)=c(S,T)$ </p><p>定义 $f(X,Y)=\sum \limits_{u \in X} \sum \limits_{v\in Y}f(u,v)-\sum \limits_{u \in X} \sum \limits_{v\in Y}f(v,u)$，所以 </p><ul><li>$f(X,Y)=-f(Y,X)$ </li><li>$f(X,X)=0$ </li><li>$f(Z,X\cup Y)=f(Z,X)+f(Z,Y)\ \ \  X\cap Y=\emptyset $ </li></ul><p>定理：割的流量等于净流量， $f(S,T)=|f|$ </p><p>证明：</p><script type="math/tex; mode=display">\begin{align*}f(S,V)&=f(S,S)+f(S,T)\\f(S,T)&=f(S,V)-f(S,S)\\&= f(S,V)\\&= f({s},V)+f(S\setminus s,V)， \left \{S\setminus s \right \} 是没有s和t的点的集合，由于流量守恒f(S\setminus s,V)=0\\&=f(s,V)\\&=|f|\end{align*}</script><p>所以还可以得到 $|f|\le c(S,T)$，净流量取小于等于割的容量</p></blockquote></li></ul><p>==最大流-最小割定理==(max-flow min-cut theorem):下面三个命题是等价的</p><ol><li>可行流 f 是最大流</li><li>可行流 f 的残留网络G~f~中不存在增广路</li><li>存在一个割 $CUT(S,T)，|f|=c(S,T)$ </li></ol><blockquote><p>1$\Longrightarrow $2  <span id="max-flow min-cut theorem"> </span> </p><p>证明：反证，假设还存在一个增广路 f’，由于G~f~的能量守恒</p><p>​    |f+f’|=|f|+|f’|,所以 f 不是最大流，与命题1矛盾。</p><p>2$\Longrightarrow $3</p><p>证明：在G~f~不存在增广路的情况下构造一个割，使之|f|=c(S,T)</p><p>定义S为，从 G~f~ 的源点 s 出发，沿容量大于0的边能到达的所有点，显然不能到达汇点 t，那么 $T=V\setminus S, S\cup T=V$,所以这种划分是原网络 G 的一个割CUT(S,T)。</p><p>对于这个割，正向割边流量为该边容量，逆向割边流量为0。</p><script type="math/tex; mode=display">\begin{align*}|f| &=\sum \limits_{u\in S} \sum \limits_{v\in T} f(u,v)-\sum \limits_{u\in S} \sum \limits_{v\in T} f(v,u)\\&=\sum \limits_{u\in S} \sum \limits_{v\in T} f(u,v)\\&=c(S,T) \ \ \ \ 得证\end{align*}</script><p>3$\Longrightarrow $1</p><p>证明：已知任何一个流 $|f|\le c(S,T)$，所以最大流也 $\le c(S,T)$ </p><p>​    3中，$|f|=c(S,T)$ , 所以 $|f|\ge最大流$ </p><p>​    又显然任何一个流都小于等于最大流, 夹逼得证，还能说明这个割是最小割，如下定理</p><p>定理：最大流等于最小割</p><p>证明：由3可知，最小割 $\le$ c(S,T) = |f| $\le$ 最大流，</p><p>​    而最大流 $\le$ 最小割，所以最大流等于最小割</p></blockquote><h3 id="1-2-求最大流"><a href="#1-2-求最大流" class="headerlink" title="1.2 求最大流"></a>1.2 求最大流</h3><p>使用Ford-Fulkerson方法 即增广路方法 简称FF方法。</p><p>开始，对于所有结点 $f(u,v)=f(v,u)=0,\ \ u,v\in V$，给出的初始流值为0。在每一次迭代中，将 G 的流值增加，方法就是在残留网络　G~f~ 中寻找一条增广路径（一般用 BFS 算法遍历残留网络中各个结点，以此寻找增广路径），然后在增广路径中的每条边都增加等量的流值，这个流值的大小就是增广路径上的最大残余流量，反向边减去流量。重复这一过程，直到残余网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法获得一个最大流。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Ford-Fulkerson(G,s,t)伪代码:for each edge(u,v) 属于 E（G）f[u,v]=0  f[v,u]=0 // 初始化流量为 0// 根据最大流最小割定理，当不再有增广路径时，流 f 就是最大流while there exists a path p from s to t in the residual network G_f    cf(p)=min{cf(u,v):(u,v)is in p}  // cf(p)为该路径的残余容量    for each edge (u,v) in p    f[u,v]=+cf(p)  //为该路径中的每条边中注入刚才找到到的残余容量        f[v,u]=-cf(p)   //反向边注入反向流量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1-EK算法"><a href="#1-2-1-EK算法" class="headerlink" title="1.2.1 EK算法"></a>1.2.1 EK算法</h4><p><strong>存图方式</strong>：邻接表</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}// 遍历方式，DFSint dfs(int u){    st[u] = true; // st[u] 表示点u已经被遍历过    for (int i = h[u]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j]) dfs(j);    }}// 遍历方式，BFSqueue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size()){    int t = q.front();    q.pop();    for (int i = h[t]; i != -1; i = ne[i])    {        int j = e[i];        if (!st[j])        {            st[j] = true; // 表示点j已经被遍历过            q.push(j);        }    }}// 初始化idx = 0;memset(h, -1, sizeof h);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-Dinic算法"><a href="#1-2-2-Dinic算法" class="headerlink" title="1.2.2 Dinic算法"></a>1.2.2 Dinic算法</h4><h4 id="1-2-3-ISAP算法"><a href="#1-2-3-ISAP算法" class="headerlink" title="1.2.3 ISAP算法"></a>1.2.3 ISAP算法</h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学</title>
      <link href="/tu-xing-xue/tu-xing-xue/"/>
      <url>/tu-xing-xue/tu-xing-xue/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-二值化"><a href="#1-1-二值化" class="headerlink" title="1.1 二值化"></a>1.1 二值化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double cv::threshold(         InputArray  src,    // 输入OutputArray dst,    // 输出double  thresh, // 阈值double  maxval, // 最大值int      type    // 阈值类型) Mat gray;cvtColor(img, gray, COLOR_BGR2GRAY);MatimgB, imgBInv, imgTrunc, imgTZ, imgTZInv;// 也可进行彩色图像的阈值化threshold(gray, imgTrunc, 125, 255, THRESH_TRUNC);threshold(gray, imgB, 125, 255, THRESH_BINARY);threshold(gray, imgBInv, 125, 255, THRESH_BINARY_INV);threshold(gray, imgTrunc, 125, 255, THRESH_TRUNC);threshold(gray, imgTZ, 125, 255, THRESH_TOZERO);threshold(gray, imgTZInv, 125, 255, THRESH_TOZERO_INV);// 使用Otsu算法threshold(gray, imgB, 125, 255, THRESH_BINARY | THRESH_OTSU);  // 返回值为算法自动确定的阈值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本项目采用 OTSU 大津阈值, 原理:<br>核心思想是通过自动计算一个最优阈值，将图像划分为前景（通常是感兴趣的目标区域）和背景两部分，以达到最佳的图像分割效果</p><p><strong>动态二值化</strong><br>adaptiveThreshold()<br>DAPTIVE_THRESH_MEAN_C：使用邻域内像素的平均值作为阈值基础，然后加上或减去常数C。<br>ADAPTIVE_THRESH_GAUSSIAN_C：使用邻域内像素的加权高斯平均值作为阈值基础，然后加上或减去常数C。加权高斯平均对邻域内像素赋予不同的权重，离中心像素越近的像素权重越大。</p><h2 id="1-2-腐蚀膨胀"><a href="#1-2-腐蚀膨胀" class="headerlink" title="1.2 腐蚀膨胀"></a>1.2 腐蚀膨胀</h2><p>腐蚀，去除毛刺<br>erode</p><p>膨胀，填补空缺<br>dilate</p><p>开运算：先腐蚀再膨胀<br>闭运算：先膨胀再腐蚀</p><h2 id="1-3-仿射"><a href="#1-3-仿射" class="headerlink" title="1.3 仿射"></a>1.3 仿射</h2><p>二维坐标到二维坐标的线性变换，保持了平直性和平行性</p><p><strong>获取仿射矩阵</strong><br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//（1）getAffineTransform       //三点法Mat M1=getAffineTransform(const Point2f* src, const Point2f* dst)  //参数const Point2f* src：原图的三个固定顶点  //参数const Point2f* dst：目标图像的三个固定顶点          //返回值：Mat型变换矩阵，可直接用于warpAffine()函数         //注意，顶点数组长度超过3个，则会自动以前3个为变换顶点；数组可用Point2f[]或Point2f*表示//（2）getRotationMatrix2D       //直接指定比例和角度Mat M2=getRotationMatrix2D (CvPoint2D32f  center,double angle,double scale)            //参数CvPoint2D32f  center，表示源图像旋转中心            //参数double angle，旋转角度，正值表示逆时针旋转            //参数double scale，缩放系数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>进行仿射变换</strong><br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">C++ void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar&amp; borderValue=Scalar())   //参数InputArray src：输入变换前图像//参数OutputArray dst：输出变换后图像，需要初始化一个空矩阵用来保存结果，不用设定矩阵尺寸//参数InputArray M：变换矩阵，用另一个函数getAffineTransform()计算//参数Size dsize：设置输出图像大小//参数int flags = INTER_LINEAR：设置插值方式，默认方式为线性插值(另一种WARP_FILL_OUTLIERS)    //参数int borderMode=BORDER_CONSTANT：边界像素模式，默认值BORDER_CONSTANT    //参数const Scalar&amp; borderValue=Scalar()，在恒定边界情况下取的值，默认值为Scalar（），即0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>透视变换是将图像投影到一个新的视平面<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//（1）四点法MatgetPerspectiveTransform(const Point2f* src, const Point2f* dst)//参数const Point2f* src：原图的四个固定顶点//参数const Point2f* dst：目标图像的四个固定顶点//返回值：Mat型变换矩阵，可直接用于warpAffine()函数//注意，顶点数组长度超4个，则会自动以前4个为变换顶点；数组可用Point2f[]或Point2f*表示    //注意：透视变换的点选取变为4个 //（2）进行透视变换 void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar&amp; borderValue=Scalar())//参数InputArray src：输入变换前图像//参数OutputArray dst：输出变换后图像，需要初始化一个空矩阵用来保存结果，不用设定矩阵尺寸//参数InputArray M：变换矩阵，用另一个函数getAffineTransform()计算//参数Size dsize：设置输出图像大小//参数int flags = INTER_LINEAR：设置插值方式，默认方式为线性插值(另一种WARP_FILL_OUTLIERS)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="1-4-sobel-定位"><a href="#1-4-sobel-定位" class="headerlink" title="1.4 sobel 定位"></a>1.4 sobel 定位</h2><p>sobel 通过计算图像的梯度，然后给个梯度阈值进行处理的</p><p>高斯模糊，灰度化，边缘化（sobel突出车牌边缘），二值化（大津法），闭操作（将相邻的白色区域扩大 连接成一个整体）</p><p>然后利用车牌特点进行初步筛选，如宽高比，面积等</p><h2 id="1-5-颜色定位"><a href="#1-5-颜色定位" class="headerlink" title="1.5 颜色定位"></a>1.5 颜色定位</h2><p>HSV，色调，饱和度，亮度，将色彩和其他分离，符合我们只关注颜色的情况。<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cv::cvtColor(inputImage, hsvImage, cv::COLOR_BGR2HSV);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>将 BGR 转为 HSV，是因为在BGR空间中，由于亮度和颜色信息混合在一起，设置合适的阈值较为困难。而在HSV空间中，可以针对H、S、V三个分量分别设置阈值，更易于分离出目标颜色的特定范围。</p><h2 id="1-6-HOG"><a href="#1-6-HOG" class="headerlink" title="1.6 HOG"></a>1.6 HOG</h2><p>首先计算梯度，把整个图像划分为若干个8x8的小单元，基于图像的梯度对每个cell创建了一个直方图。</p><p>Block 归一化，最后计算整个图像的特征描述符。</p><p><strong>计算方式：</strong><br>比如上面这个图，将整幅图像划分成cell的个数为8x16，就是横向有8个cell，纵向有16个cell。每个block有2x2个cell的话，那么block的个数为：(16-1)x(8-1)=105。即有7个水平block和15个竖直block。再将这105个block合并，就得到了整个图像的特征描述符，长度为 105×36=3780。</p><p>定向梯度直方图<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">HOGDescriptor hog;int h = image.rows;int w = image.cols;float rate = 64.0 / w;Mat img, gray;resize(image, img, Size(64, int(rate*h)));cvtColor(img, gray, COLOR_BGR2GRAY);Mat result = Mat::zeros(Size(64, 128), CV_8UC1);result = Scalar(127);Rect roi;roi.x = 0;roi.width = 64;roi.y = (128 - gray.rows) / 2;roi.height = gray.rows;gray.copyTo(result(roi));hog.compute(result, desc, Size(8, 8), Size(0, 0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="1-7-SVM"><a href="#1-7-SVM" class="headerlink" title="1.7 SVM"></a>1.7 SVM</h2><p>把HOG特征描述作为SVM训练对象</p><h2 id="1-8-ANN"><a href="#1-8-ANN" class="headerlink" title="1.8 ANN"></a>1.8 ANN</h2><p>MLP 层叠加</p><h2 id="1-9-哈里斯角点"><a href="#1-9-哈里斯角点" class="headerlink" title="1.9 哈里斯角点"></a>1.9 哈里斯角点</h2><pre><code>左图表示一个平坦区域，在各方向移动，窗口内像素值均没有太大变化；中图表示一个边缘特征（Edges），如果沿着水平方向移动(梯度方向)，像素值会发生跳变；如果沿着边缘移动(平行于边缘) ，像素值不会发生变化；右图表示一个角（Corners），不管你把它朝哪个方向移动，像素值都会发生很大变化。</code></pre><p>算法的核心是<strong>利用局部窗口在图像上进行移动，判断灰度是否发生较大的变化</strong>。<br>如果窗口内的灰度值（在梯度图上）都有较大的变化，那么这个窗口所在区域就存在角点。</p><p>这样就可以将 Harris 角点检测算法分为以下三步：</p><pre><code>当窗口（局部区域）同时向 x （水平）和 y（垂直） 两个方向移动时，计算窗口内部的像素值变化量 E(x,y) ；对于每个窗口，都计算其对应的一个角点响应函数 R；然后对该函数进行阈值处理，如果 R&gt;threshold，表示该窗口对应一个角点特征。</code></pre><h1 id="2-实习"><a href="#2-实习" class="headerlink" title="2 实习"></a>2 实习</h1><p><strong>YUV 图像: </strong><br>YUV方式传送占用极少的频宽</p><p>Y（Luminance）：表示图像的<strong>亮度信息</strong>，与灰度图像类似，包含了图像的明暗层次和大部分视觉信息。Y分量通常占用全部带宽，可以直接转换为灰度图像显示。</p><p>U和V（Chrominance）：<strong>色度</strong>, 分别表示图像的蓝色差（Blue-Difference，U）和红色差（Red-Difference，V）。它们描述了图像色彩相对于亮度的偏差，用于编码颜色信息。U和V分量通常占用较少的带宽，通过与Y分量结合，可以重建完整的彩色图像。</p><p>YUV 4:4:4采样，每一个Y对应一组UV分量。<br>YUV 4:2:2采样，每两个Y共用一组UV分量。<br>YUV 4:2:0采样，每四个Y共用一组UV分量。</p><p><strong>RGB图像</strong></p><p>RGB16格式: RGB16数据格式主要有二种：RGB565 和 RGB555。</p><p> RGB565   每个像素用16比特位表示，占2个字节，RGB分量分别使用5位、6位、5位。</p><p> RGB555   每个像素用16比特位表示，占2个字节，RGB分量都使用5位(最高位不用)。</p><p>RGB32格式</p><p>RGB32图像每个像素用32比特位表示，占4个字节，R，G，B分量分别用8个bit表示，存储顺序为B，G，R，最后8个字节保留。</p><p>java默认使用大端字节序，c/c++默认使用小端字节序，android平台下Bitmap.config.ARGB_8888的Bitmap默认是大端字节序，当需要把这个图片内存数据给小端语言使用的时候，就需要把大端字节序转换为小端字节序。</p><p>例如：java层的ARGB_8888传递给jni层使用时，需要把java层的ARGB_8888的内存数据转换为BGRA8888</p><p>NV21是一种常用的YUV颜色空间编码格式，属于YUV4:2:0采样方案。它是Android设备摄像头预览数据的标准格式之一</p><h2 id="3-Opencv"><a href="#3-Opencv" class="headerlink" title="3 Opencv"></a>3 Opencv</h2><p>1.opencv中RGB2GRAY是怎么实现的</p><p>输出的灰度图像是RGB三种颜色通道的加权和；</p><p>Gray = 0.29900 <em> R + 0.58700 </em> G + 0.11400 * B</p><p>2.连续图像转化为数字图像需要进行哪些操作？</p><p>答：取样 量化</p><p>3 图像边缘检测中常用的边缘检测算子有哪些？</p><p>答：Roberts算子、Prewitt算子、Sobel算子、Canny算子、Laplacian算子等。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English Words</title>
      <link href="/ying-yu/englishwords/"/>
      <url>/ying-yu/englishwords/</url>
      
        <content type="html"><![CDATA[<p>coordinate  n.坐标；套装； v.协调</p><p>scenario    n.方案；设想</p><p>inclusive   a.包含的</p><p>cutoff      n.界限</p><p>unidirectional a.单向的</p><p>suffix      n.后缀</p><p>segment     n.部分；段</p><p>scalar      n.标量</p><p>normalize   v.归一化；标准化</p><p>inplace     n.原地，原位</p><p>compose     v.组和</p><p>batch       n.批，一批</p><p>shuffle     v.洗牌</p><p>tensor      n.张量</p><p>kernel      n.卷积核，核</p><p>subscriptable a.有下标的</p><p>arbitrary   a.任意的</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch入门</title>
      <link href="/shen-du-xue-xi/pytorch/"/>
      <url>/shen-du-xue-xi/pytorch/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 查看 package 的信息</span><span class="token builtin">dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。</p><p>张量的四个参数： </p><p>batch_size：批尺寸，图片的个数</p><p>通道数：像彩色图像有RGB三通道，即一张图片的feature map个数</p><p>图像的高度 H</p><p>图像的宽度 W</p><h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">My</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pic<span class="token punctuation">)</span>    <span class="token keyword">pass</span>my <span class="token operator">=</span> My  <span class="token comment"># 创建实例</span>my<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>   <span class="token comment"># 会调用 __getitem__()</span>img <span class="token operator">=</span> my<span class="token punctuation">(</span>pic<span class="token punctuation">)</span><span class="token comment"># __call__()相当于重载了 （），使得实例直接跟()调用call函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在类中定义了getitem()方法，那么它的实例对象（假设为P）就可以以P[key]形式取值，当实例对象做P[key]运算时，就会调用类中的<strong>getitem</strong>()方法。当对类的属性进行下标的操作时，首先会被<strong>getitem</strong>() 拦截，从而执行在<strong>getitem</strong>()方法中设定的操作，如赋值，修改内容，删除内容等。</p><h2 id="2-Tensorboard的使用"><a href="#2-Tensorboard的使用" class="headerlink" title="2 Tensorboard的使用"></a>2 Tensorboard的使用</h2><p><strong>TensorBoard</strong> 是一个可视化工具，它可以用来展示网络图、张量的指标变化、张量的分布情况等。特别是在训练网络的时候，我们可以设置不同的参数（比如：权重W、偏置B、卷积层数、全连接层数等），使用TensorBoader可以很直观的帮我们进行参数的选择。</p><p>TensorBoard的使用一共可分成四步：</p><ol><li>设置保存路径：tenboard_dir = ‘./tensorboard/test1/‘</li><li>指定一个文件用来保存TensorFlow的图：writer = tf.summary.FileWriter(tenboard_dir + hparam)</li><li>把图add进去：writer.add_graph(sess.graph)</li><li>进入test1文件夹的上一层文件夹，在DOS窗口运行命令：tensorboard —logdir=./test1://blog.csdn.net/duanlianvip/article/details/98498826</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span>  <span class="token comment"># 初始化一个实例</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"y=x"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token punctuation">)</span>  <span class="token comment"># 标题，保存的数值（y轴），步数(x轴)</span>writer<span class="token punctuation">.</span>add_image<span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> img_array<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> dataformats<span class="token operator">=</span><span class="token string">'HWC'</span><span class="token punctuation">)</span><span class="token comment"># 名字；np.array，格式的图片；第几张图片；默认（3，H，W），指定为（HWC）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tensorboard —logdir=logs</p><p>tensorboard —logdir=logs —port=6007</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test_loader<span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data   <span class="token comment"># data 为打包四个数据，默认随机选取</span>    <span class="token comment"># print(imgs.shape)  # torch.Size([5, 3, 32, 32])</span>    <span class="token comment"># print(targets)     # tensor([3, 6, 1, 9, 1])   一个列表，长度为 batch_size</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"test_data"</span><span class="token punctuation">,</span> imgs<span class="token punctuation">,</span> step<span class="token punctuation">)</span>  <span class="token comment"># 可以同时显示多个图片</span>    step <span class="token operator">+=</span> <span class="token number">1</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112011635506.png" alt="image-20211201163503439"></p><h2 id="3-Transforms的使用"><a href="#3-Transforms的使用" class="headerlink" title="3 Transforms的使用"></a>3 Transforms的使用</h2><p>对图片进行处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transformstool <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 从transforms选工具</span>result <span class="token operator">=</span> tool<span class="token punctuation">(</span>pic<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Tensor 图片数据类型：含有神经网络需要的参数。</p><p>归一化：</p><p><strong>归一化</strong>就是要把需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">'''output[channel] = (input[channel] - mean[channel]) / std[channel]mean (sequence): Sequence of means for each channel.std (sequence): Sequence of standard deviations for each channel.inplace(bool,optional): Bool to make this operation in-place.你所用的方法是否改变原数据。'''</span>trans_norm <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span>mean<span class="token punctuation">,</span> std<span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Resize</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">trans_resize <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">)</span>img_resize <span class="token operator">=</span> trans_resize<span class="token punctuation">(</span>img<span class="token punctuation">)</span>  <span class="token comment"># 均为 PIL 类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>img_resize<span class="token punctuation">)</span>   <span class="token comment"># to 512×512</span>img_resize <span class="token operator">=</span> tensor_trans<span class="token punctuation">(</span>img_resize<span class="token punctuation">)</span>  <span class="token comment"># PIL to Tensor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Compose : 将多个 transforms 操作整合到一块，参数是 transforms 类型的列表，调用时将按列表顺序执行</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将 Resize 和 ToTensor 整合到 trans_compose</span>trans_compose <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>trans_resize_2<span class="token punctuation">,</span> tensor_trans<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 对 img 进行 compose 里面每一个步骤trans_resize_2 和 tensor_trans</span>img_resize_2 <span class="token operator">=</span> trans_compose<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token comment"># 相当于</span>img_resize_2 <span class="token operator">=</span> trans_resize_2<span class="token punctuation">(</span>img<span class="token punctuation">)</span>img_resize_2 <span class="token operator">=</span> tensor_trans<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RandomCrop : 随机裁剪</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">trans_random_crop <span class="token operator">=</span> transforms<span class="token punctuation">.</span>RandomCrop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">]</span><span class="token punctuation">)</span>trans_compose_2 <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>trans_random_crop<span class="token punctuation">,</span> tensor_trans<span class="token punctuation">]</span><span class="token punctuation">)</span>img_crop <span class="token operator">=</span> trans_compose_2<span class="token punctuation">(</span>img<span class="token punctuation">)</span>  <span class="token comment"># 随机裁剪 img 使之符合指定尺寸</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-torchvision-数据集"><a href="#4-torchvision-数据集" class="headerlink" title="4 torchvision 数据集"></a>4 torchvision 数据集</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 下载数据集</span>train_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment"># 包含有 __getitem__:  retrun img, target，图片和通道</span>img<span class="token punctuation">,</span> target <span class="token operator">=</span> test_set<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-dataloader-数据集"><a href="#5-dataloader-数据集" class="headerlink" title="5 dataloader 数据集"></a>5 dataloader 数据集</h2><p><a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.DataLoader">dataloader</a> </p><p>==dataset== (Dataset): dataset from which to load the data.<br>==batch_size== (int, optional): how many samples per batch to load (default: <code>1</code>).</p><p>例：batch_size = n:</p><p>将img1,img2,···,imgn 打包成 imgs</p><p>将target1,···,targetn 打包成 targets</p><p>在 dataloader 中的 getitem  return imgs,targets</p><p>==shuffle== (bool, optional): set to <code>True</code> to have the data reshuffled at every epoch (default: <code>False</code>).<br>==num_workers== (int, optional): how many subprocesses to use for data loading.<code>0</code> means that the data will be loaded in the main process. (default: <code>0</code>)<br>==drop_last== (bool, optional): set to <code>True</code> to drop the last incomplete batch,(default: <code>0</code>)</p><p>就是若已 8×8 的方式组图，最后一组不够64张，若 True 则舍去，否则 即使不够也显示</p><h2 id="6-神经网络-Neural-Net"><a href="#6-神经网络-Neural-Net" class="headerlink" title="6 神经网络 Neural Net"></a>6 <a href="https://pytorch.org/docs/stable/nn.html">神经网络 Neural Net</a></h2><p>输入 → forward函数 → 输出</p><p>输入 → backward函数 → 输出</p><h3 id="6-1-卷积计算的过程"><a href="#6-1-卷积计算的过程" class="headerlink" title="6.1 卷积计算的过程"></a>6.1 卷积计算的过程</h3><p><a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">动图演示</a> </p><p>卷积 → Relu → 池化</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E5%8D%B7%E7%A7%AF1.png" alt="v2-68a6efb63fbbb0b83ebded0d6268d0fe_1440w"></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E5%8D%B7%E7%A7%AF2.png" alt="v2-683c8d63e22eef01a271a08016006d17_1440w"></p><p>Stride=1，滑动步长为1</p><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d">cov2d</a>  </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token comment"># 卷积核</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 第一次卷积要求仅有单个张量输入，所以要reshape</span><span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>output1 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 改变滑动步长</span>output2 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment"># padding：填充，上限是维持feature map 大小与原图大小一致，使卷积后的尺寸和原尺寸相同.具体增加pixel的数量多少，由filter的尺寸和stride大小共同决定，默认为 0</span>output3 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''output1:tensor([[[[11, 12, 12],           [21, 17, 17],          [13, 10,  4]]]])output2:tensor([[[[11, 12],            [13,  4]]]])output3:tensor([[[[ 2,  5,  7, 11,  8],            [ 7, 11, 12, 12,  6],            [ 9, 21, 17, 17,  8],            [12, 13, 10,  4,  4],            [14, 13,  9,  7,  4]]]])'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112021213866.png" alt="image-20211202121247953"></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031120878.png" alt="image-20211203111843714"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyModule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MyModule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 卷积层</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x    module1 <span class="token operator">=</span> MyModule<span class="token punctuation">(</span><span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>   <span class="token comment"># Dataloader对象只能使用 iter() 迭代器访问</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data    output <span class="token operator">=</span> module1<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>  <span class="token comment"># output.shape=torch.Size([64, 6, 30, 30])</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> imgs<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    <span class="token comment"># channels不吻合，需要改变参数，与之对应</span>    <span class="token comment"># channels变小，说明，batch_size变大，传入-1，batch_size 自动计算</span>    output <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    step <span class="token operator">+=</span> <span class="token number">1</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-最大池化"><a href="#6-2-最大池化" class="headerlink" title="6.2 最大池化"></a>6.2 最大池化</h3><p>最大池化：<a href="https://pytorch.org/docs/stable/generated/torch.nn.MaxPool2d.html?highlight=maxpool#torch.nn.MaxPool2d">MaxPool2d</a> </p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E6%B1%A0%E5%8C%961.png" alt="v2-bc7736e0a815c8db07a855c35234b76e_1440w"></p><p>ceil_mode = True 和 False</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E6%B1%A0%E5%8C%962.png" alt="v2-e58c86e2a784a341afe648607ab2f1a7_1440w"></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112021413532.png" alt="image-20211202141352240"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Mymodule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Mymodule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>maxpool1 <span class="token operator">=</span> MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> ceil_mode<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        output <span class="token operator">=</span> self<span class="token punctuation">.</span>maxpool1<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> outputmymodule <span class="token operator">=</span> Mymodule<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> mymodule<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-非线性激活"><a href="#6-3-非线性激活" class="headerlink" title="6.3 非线性激活"></a>6.3 非线性激活</h3><p><a href="https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity">Non-linear Activations (weighted sum, nonlinearity)</a> </p><p>==Relu函数==</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/Relu%E5%87%BD%E6%95%B0.png" alt="v2-f9af9fde70d5d3b7db5562956c6cc213_1440w"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> ReLU<span class="token punctuation">,</span> Sigmoid<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span class="token triple-quoted-string string">'''input = torch.tensor(([    [1, -0.5],    [-1, 3]]))input = torch.reshape(input, (-1, 1, 2, 2))print(input)'''</span>dataset_transform <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>dataset_transform<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Mymodule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Mymodule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># self.relu1 = ReLU()</span>        self<span class="token punctuation">.</span>sigmoid1 <span class="token operator">=</span> Sigmoid<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># x = self.relu1(x)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>sigmoid1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xmymoudle <span class="token operator">=</span> Mymodule<span class="token punctuation">(</span><span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"intput"</span><span class="token punctuation">,</span> imgs<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    output <span class="token operator">=</span> mymoudle<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    step <span class="token operator">+=</span> <span class="token number">1</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-线性层"><a href="#6-4-线性层" class="headerlink" title="6.4 线性层"></a>6.4 线性层</h3><p><a href="https://pytorch.org/docs/stable/nn.html#linear-layers">Linear Layers</a> </p><p>torch.nn.Linear(<em>in_features</em>, <em>out_features</em>, <em>bias=True</em>, <em>device=None</em>, <em>dtype=None</em>)</p><ul><li><strong>in_features</strong> – size of each input sample</li><li><strong>out_features</strong> – size of each output sample</li><li><strong>bias</strong> – If set to <code>False</code>, the layer will not learn an additive bias. Default: <code>True</code></li></ul><p>Applies a linear transformation to the incoming data: $y=xA^T+b $ </p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E7%BA%BF%E6%80%A7%E5%B1%82.png" alt="image-20211202164141121"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Linear<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoaderdataset_transform <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>test_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>dataset_transform<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> drop_last<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Mymodule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Mymodule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>linear1 <span class="token operator">=</span> Linear<span class="token punctuation">(</span><span class="token number">196608</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>linear1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xmymoudle <span class="token operator">=</span> Mymodule<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    output <span class="token operator">=</span> torch<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    output <span class="token operator">=</span> mymoudle<span class="token punctuation">(</span>output<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-Sequential"><a href="#6-4-Sequential" class="headerlink" title="6.4 Sequential"></a>6.4 Sequential</h3><p>按顺序执行里面的模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">net5</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>net5<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>block <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>block<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031122420.png" alt="image-20211203112214347"></p><p>步骤如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyModule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MyModule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># self.conv1 = Conv2d(3, 32, 5, padding=2)</span>        <span class="token comment"># self.maxpool1 = MaxPool2d(2)</span>        <span class="token comment"># self.conv2 = Conv2d(32, 32, 5, padding=2)</span>        <span class="token comment"># self.maxpool2 = MaxPool2d(2)</span>        <span class="token comment"># self.conv3 = Conv2d(32, 64, 5, padding=2)</span>        <span class="token comment"># self.maxpool3 = MaxPool2d(2)</span>        <span class="token comment"># self.flatten = Flatten()</span>        <span class="token comment"># self.linear1 = Linear(1024, 64)</span>        <span class="token comment"># self.linear2 = Linear(64, 10)</span>        self<span class="token punctuation">.</span>model1 <span class="token operator">=</span> Sequential<span class="token punctuation">(</span> <span class="token comment">#  使代码结构化</span>            Conv2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Conv2d<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Conv2d<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Linear<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Linear<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># x = self.conv1(x)</span>        <span class="token comment"># x = self.maxpool1(x)</span>        <span class="token comment"># x = self.conv2(x)</span>        <span class="token comment"># x = self.maxpool2(x)</span>        <span class="token comment"># x = self.conv3(x)</span>        <span class="token comment"># x = self.maxpool3(x)</span>        <span class="token comment"># x = self.flatten(x)</span>        <span class="token comment"># x = self.linear1(x)</span>        <span class="token comment"># x = self.linear2(x)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>model1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xmymodule1 <span class="token operator">=</span> MyModule<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>mymodule1<span class="token punctuation">)</span><span class="token comment"># 张量的尺寸： batch_size,通道,单个feature map的 H, W</span><span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span>output <span class="token operator">=</span> mymodule1<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment"># 可视化</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span>writer<span class="token punctuation">.</span>add_graph<span class="token punctuation">(</span>mymodule1<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031135304.png" alt="image-20211203113505238"></p><h2 id="7-损失函数与反向传播"><a href="#7-损失函数与反向传播" class="headerlink" title="7 损失函数与反向传播"></a>7 损失函数与反向传播</h2><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.L1Loss.html?highlight=l1loss#torch.nn.L1Loss">L1Loss</a>  绝对值损失</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031319592.png" alt="image-20211203131956430"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> L1Lossinputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>targets <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token comment"># 大小需要相同</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>targets <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>targets<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>loss1 <span class="token operator">=</span> L1Loss<span class="token punctuation">(</span><span class="token punctuation">)</span>result1 <span class="token operator">=</span> loss1<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span>  <span class="token comment"># (5-3)/3</span>loss2 <span class="token operator">=</span> L1Loss<span class="token punctuation">(</span>reduction<span class="token operator">=</span><span class="token string">'sum'</span><span class="token punctuation">)</span>result2 <span class="token operator">=</span> loss2<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>  <span class="token comment"># (5-3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html?highlight=loss#torch.nn.MSELoss">MSELoss</a>  平方损失</p><p>$l_n=(x_n−y_n)^2$  </p><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html?highlight=loss#torch.nn.CrossEntropyLoss">CrossEntropyLoss</a>  交叉熵损失</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031518030.png" alt="image-20211203151841862"> </p><p>softmax: $p(y|x)=\frac{exp(f_y)}{\sum_{c=1}^Cexp(f_c)}=softmax(f)_y$ </p><p>softmax就是模型已经有分类预测结果以后，将预测结果输入softmax函数，进行 <strong>非负性</strong> 和 <strong>归一化</strong> 处理，最后得到0-1之内的分类概率。先指数化，再除指数化的和。</p><p>negative log likelihood loss（nll_loss)：$f(x,class)=-x[class]$ class为索引</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cross_loss <span class="token operator">=</span> CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>result3 <span class="token operator">=</span> cross_loss<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向传播：grad 梯度</p><p>梯度：<em>梯度</em>的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此<em>梯度</em>的方向）变化最快，变化率最大（为该<em>梯度</em>的模）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                     transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyModule</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>MyModule<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>model1 <span class="token operator">=</span> Sequential<span class="token punctuation">(</span>            Conv2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Conv2d<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Conv2d<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Linear<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            Linear<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>model1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xcross_loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>module1 <span class="token operator">=</span> MyModule<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data    outputs <span class="token operator">=</span> module1<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    result <span class="token operator">=</span> cross_loss<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    result<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-优化器"><a href="#8-优化器" class="headerlink" title="8 优化器"></a>8 优化器</h2><p><a href="https://pytorch.org/docs/stable/optim.html?highlight=optim#module-torch.optim">optim</a> ：用于优化模型参数</p><p>SGD: 随机梯度下降</p><ul><li>params (iterable)：iterable of parameters to optimize or dicts defining parameter groups</li><li>lr (float)：learning rate</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">cross_loss <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>module1 <span class="token operator">=</span> MyModule<span class="token punctuation">(</span><span class="token punctuation">)</span>optim <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>module1<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    running_loss <span class="token operator">=</span> <span class="token number">0.0</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>        imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data        outputs <span class="token operator">=</span> module1<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>        result <span class="token operator">=</span> cross_loss<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>        optim<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 设置梯度为 0</span>        result<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optim<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>              running_loss <span class="token operator">+=</span> result    <span class="token keyword">print</span><span class="token punctuation">(</span>running_loss<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031611430.png" alt="image-20211203161137337"></p><h2 id="9-现有模型"><a href="#9-现有模型" class="headerlink" title="9 现有模型"></a>9 现有模型</h2><h3 id="9-1-添加或修改模型"><a href="#9-1-添加或修改模型" class="headerlink" title="9.1 添加或修改模型"></a>9.1 添加或修改模型</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 默认模型结构</span>vgg16 <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>vgg16<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 训练好的模型</span>vgg16_true <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>vgg16<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>vgg16_true<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'add_linear'</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>vgg16_true<span class="token punctuation">.</span>classifier<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span><span class="token string">'add_linear'</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>vgg16<span class="token punctuation">.</span>classifier<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031649924.png" alt="image-20211203164941761"></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031650606.png" alt="image-20211203165048419"></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112031651724.png" alt="image-20211203165151403"></p><h3 id="9-2-模型的保存和读取"><a href="#9-2-模型的保存和读取" class="headerlink" title="9.2 模型的保存和读取"></a>9.2 模型的保存和读取</h3><p>两种方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vgg16 <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>models<span class="token punctuation">.</span>vgg16<span class="token punctuation">(</span>pretrained<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>model <span class="token operator">=</span> torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"vgg16_method1.pth"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>vgg16<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"vgg16_method2.pth"</span><span class="token punctuation">)</span>vgg16<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"vgg16_method2.pth"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>推荐第二种</p><h2 id="10-完整的模型训练套路"><a href="#10-完整的模型训练套路" class="headerlink" title="10 完整的模型训练套路"></a>10 完整的模型训练套路</h2><p>output 与 targets 的比较</p><p>argmax: arguments of the maxima，是使函数值最大化的输入或参数。可看作使 y 最大时 x 的取值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchoutputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">0.05</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 竖着看 0.2 和 0.4 【0，1】,给出该列的横坐标</span><span class="token keyword">print</span><span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 横着看 0.1 和 0.4 【1，1】,给出该行的纵坐标</span><span class="token keyword">print</span><span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 通常选取每行的最大值，即选最大概率的类</span>preds <span class="token operator">=</span> outputs<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>targets <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"--------比较--------"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>preds<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>targets<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"比较的结果： {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>preds <span class="token operator">==</span> targets<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"比较正确的个数: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token punctuation">(</span>preds <span class="token operator">==</span> targets<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''  输出tensor([1, 1])tensor([0, 1])比较的结果： tensor([False,  True])比较正确的个数: 1'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个完整的模板</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Conv2d<span class="token punctuation">,</span> Sequential<span class="token punctuation">,</span> MaxPool2d<span class="token punctuation">,</span> Flatten<span class="token punctuation">,</span> Linear<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span class="token keyword">import</span> testmodel<span class="token comment"># 数据集</span>train_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                        transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                        transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>train_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>test_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span>train_data_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>test_data_size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_data<span class="token punctuation">)</span><span class="token comment"># print("训练集大小：{}".format(train_data_size))</span><span class="token comment"># print("测试集大小：{}".format(test_data_size))</span><span class="token comment"># 创建网络模型</span>mymodel <span class="token operator">=</span> testmodel<span class="token punctuation">.</span>MyModule<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 损失函数</span>loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 优化器</span>learning_rate <span class="token operator">=</span> <span class="token number">0.01</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>mymodel<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span><span class="token comment"># 设置训练网络参数</span>total_train_step <span class="token operator">=</span> <span class="token number">0</span>total_test_step <span class="token operator">=</span> <span class="token number">0</span>epoch <span class="token operator">=</span> <span class="token number">10</span><span class="token comment"># 可视化</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"------------第 {} 轮训练------------"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 训练</span>    mymodel<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> train_dataloader<span class="token punctuation">:</span>        imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data        outputs <span class="token operator">=</span> mymodel<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>        loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>        <span class="token comment"># 优化器</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        total_train_step <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> total_train_step <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练次数 {}, loss: {} "</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>total_train_step<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"train_loss"</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total_train_step<span class="token punctuation">)</span>    <span class="token comment"># 测试</span>    mymodel<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    total_test_loss <span class="token operator">=</span> <span class="token number">0</span>    total_test_accuracy <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 强制之后的内容不进行计算图构建。</span>        <span class="token keyword">for</span> data <span class="token keyword">in</span> test_dataloader<span class="token punctuation">:</span>            imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span> data            outputs <span class="token operator">=</span> mymodel<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>            loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>            total_test_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>            accuracy <span class="token operator">=</span> <span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> targets<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            total_test_accuracy <span class="token operator">+=</span> accuracy    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"整体测试集的 Loss: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>total_test_loss<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"整体测试集的正确率: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>total_test_accuracy<span class="token operator">/</span>test_data_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"test_loss"</span><span class="token punctuation">,</span> total_test_loss<span class="token punctuation">,</span> total_test_step<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"test_accuracy"</span><span class="token punctuation">,</span> total_test_accuracy<span class="token operator">/</span>test_data_size<span class="token punctuation">,</span> total_test_step<span class="token punctuation">)</span>    total_test_step <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 保存模型</span>    torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>mymodel<span class="token punctuation">,</span> <span class="token string">"model/mymodel_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"------------模型已保存------------"</span><span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-利用GPU加速"><a href="#11-利用GPU加速" class="headerlink" title="11 利用GPU加速"></a>11 利用GPU加速</h2><p>网络模型、（imgs，targets)，优化器</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">device<span class="token operator">=</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span><span class="token string">"cpu"</span><span class="token punctuation">)</span>mymodel<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span> <span class="token comment"># 不同重新赋值</span>loss_fn<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>imgs <span class="token operator">=</span> imgs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>  <span class="token comment"># 需要重新赋值</span>targets <span class="token operator">=</span> imgs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -深度学习 -Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing竞赛题解</title>
      <link href="/ti-jie/acwing-jing-sai-ti-jie/"/>
      <url>/ti-jie/acwing-jing-sai-ti-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="DP-4078-01串"><a href="#DP-4078-01串" class="headerlink" title="DP: 4078.01串"></a><a href="https://www.acwing.com/problem/content/4081/">DP: 4078.01串</a></h3><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/4078_01串.png" alt="image-20211122072829201"></p><p>上述题目可以转化为长度在 [l,r] 范围内连续 1 个数都为 $k$ 的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111220826779.png" alt="img"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100005</span><span class="token punctuation">,</span>mod<span class="token operator">=</span><span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>ll f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> T<span class="token punctuation">,</span>k<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;=</span>k<span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>        <span class="token keyword">else</span>  f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ios<span class="token operator">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token operator">&gt;&gt;</span>T<span class="token operator">&gt;&gt;</span>k<span class="token punctuation">;</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>x<span class="token operator">&gt;&gt;</span>y<span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">-</span>s<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 相减后可能为负，因此要加模取模</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分-思维：4080-第k个数"><a href="#二分-思维：4080-第k个数" class="headerlink" title="二分+思维：4080.第k个数"></a><a href="https://www.acwing.com/problem/content/4083/">二分+思维：4080.第k个数</a></h3><p>给定一个 $n×m$ 的方格矩阵，每个方格内都有一个整数元素。其中第 $i$ 行第 $j$ 列的方格中的元素为 $i×j$（行和列都从 1 开始编号）。现在，需要你将这 $n×m$ 个整数按照非严格单调递增的顺序一一写出。</p><p>请问，你写出的第 $k$ 个整数是多少。 $(1≤n,m≤5×105，1≤k≤n×m。)$ </p><p>步骤1：给定一个数 $x$ ，判断能否知道它处于第几个位置。</p><p>是可以的，枚举每一行，当在第 $i$ 行时，这行不大于它的数有 $j$ 个，$j$ 满足 $i*j\le x，j\le \left \lfloor \frac{x}{i}\right \rfloor $。所以 $n×m$ 矩阵中不大于 $x$ 的有 $\sum_{i=1}^{n} \le min(\left \lfloor \frac{x}{i}\right \rfloor,\ \ m)$。</p><p>步骤二：$x$ 最大能到 n×m，所以枚举 $x$ 是显然不行的，但是可以发现假设 $x$ 就是答案，那么小于 $x$ 的数必然小于 $k$，和大于 $x$ 的数必然大于 $k$，因此可以使用二分。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool check(ll x){    ll sum=0;    for(int i=1;i&lt;=n;i++)        sum+=min(x/i,m);    return sum&lt;k;}if(k==1)  { cout&lt;&lt;1&lt;&lt;endl; return 0; }  ll low=1,top=n*m;while(low+1!=top) // 特例特判{    ll mid=low+top&gt;&gt;1;     if(check(mid))  low=mid;     else  top=mid;}cout&lt;&lt;top&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DP-背包-4081-最多0选数"><a href="#DP-背包-4081-最多0选数" class="headerlink" title="DP 背包: 4081.最多0选数"></a><a href="https://www.acwing.com/problem/content/4084/">DP 背包: 4081.最多0选数</a></h3><p>给定 $n$ 个整数 $ a_1,a_2,…,a_n$。请你从中选取<strong>恰好</strong> $m$ 个数，要求选出的数的乘积的末尾 0 的数量尽可能多。请输出末尾 0 的最大可能数量。</p><p>$(1≤n≤200，1≤m≤n，1≤a_i≤10^{18})$ </p><p>体积为 选出的个数，重量为 5 的个数，价值为 2 的个数，<strong>二维费用背包</strong>。</p><p>f[i,j,k] 表示从前 i 个数中选 j 个数，5 的个数为 k，2 的最大个数。限定两个求第三个。</p><p>一个 $a_i$ 中 5 的个数最多为 25 个</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 保证恰好选 m 个</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ll t<span class="token punctuation">;</span> cin<span class="token operator">&gt;&gt;</span>t<span class="token punctuation">;</span>    <span class="token keyword">int</span> a2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>a5<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> a2<span class="token operator">++</span><span class="token punctuation">,</span>t<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">%</span><span class="token number">5</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> a5<span class="token operator">++</span><span class="token punctuation">,</span>t<span class="token operator">/=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">25</span><span class="token punctuation">;</span>k<span class="token operator">&gt;=</span>a5<span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span>a5<span class="token punctuation">]</span><span class="token operator">+</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>m<span class="token operator">*</span><span class="token number">25</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>    res<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>res<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -竞赛 -题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客竞赛题解</title>
      <link href="/ti-jie/niu-ke-ti-jie/"/>
      <url>/ti-jie/niu-ke-ti-jie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/24998/C">最大边权和</a></p><p>给一张带权值的有向图，求从任意点出发不重复经过点，得到的最大权值和。</p><p>输入点个数 n ，边个数 m。然后 m 行 u、v、w 表示 u 和 v 之间有一条权值为 w 的边。</p><blockquote><p>先看一维的，给定一个数组，求最大字段和。</p><p>方法一：求前缀和，记录前面 sum[i] 最小的一个，枚举 i 后面的最大的 减去最小的即可。</p><p>方法二：DP。 f[i]=max(f[i-1]+a[i],a[i])</p></blockquote><p>因此延伸考虑 DP。从用 <strong>拓扑排序</strong> 的方式 dp，一直到终点，每次将度入度为 0 的点入队，然后用该点更新它所能到达的点。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// 入度为 0 的点入队</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// x → y</span>            f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>d<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -竞赛 -题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-基础</title>
      <link href="/suan-fa/suan-fa-bi-ji-ji-chu/"/>
      <url>/suan-fa/suan-fa-bi-ji-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1 排序"></a>1 排序</h3><h4 id="1-1-快速排序"><a href="#1-1-快速排序" class="headerlink" title="1.1 快速排序"></a>1.1 快速排序</h4><ul><li>确定分界点，这里以中间点作为分界点 x=q[l+r&gt;&gt;1]</li><li>划分两个区间，左边区间 $\le x$, 右边 区间 $\ge x$ </li><li>递归处理左右两个区间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" alt="img"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>l <span class="token operator">+</span> r <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 改为从大到小排序</span>        <span class="token comment">// do i++; while(q[i] &gt; x); // 这里和下面</span>        <span class="token comment">// do j--; while(q[j] &lt; x); // 这行的判断条件改一下</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用：求第k小</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E7%AC%ACk%E5%B0%8F.jpg" alt="img"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&gt;=</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> q<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token operator">=</span>q<span class="token punctuation">[</span>r<span class="token operator">+</span>l<span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">=</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">do</span> i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> j<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;=</span>k<span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第k小在左边</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token punctuation">(</span>j<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第k小一定在右边</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-归并排序"><a href="#1-2-归并排序" class="headerlink" title="1.2 归并排序"></a>1.2 归并排序</h4><ul><li>确定分界点,中间： l+r&gt;&gt;1</li><li>先递归排序左右两个区间</li><li>合并子问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="img"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment">//递归的终止情况</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//第一步：分成子问题</span>    <span class="token comment">//第二步：递归处理子问题</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//第三步：合并有序的两段，i，j为两段的起点</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 对当前指针到终点的赋值</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 赋值回原数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>求逆序对数</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ll <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//递归的终止情况</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//第一步：分成子问题</span>    <span class="token comment">//第二步：递归处理子问题</span>    ll res<span class="token operator">=</span><span class="token function">merge_sort</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//第三步：合并有序的两段，i，j为两段的起点</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span>res<span class="token operator">+=</span>mid<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 对当前指针到终点的赋值</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 赋值回原数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> k<span class="token operator">++</span><span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-二分"><a href="#2-二分" class="headerlink" title="2 二分"></a>2 二分</h3><p><strong>整数二分</strong>：分成两块，一左一右，low一直位于作左边，top一直位于右边，最终low在左边块最右，top在右边那块最左边。</p><p>注：首先要确保 $low$ 和 $top$ 处于不同的区域，当在同一区域或者只存在一个区域时要特判，特判很简单，什么时候会处于同一个区域呢，当然是只有一个解的时候。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token operator">!=</span>top<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> mid<span class="token operator">=</span>low<span class="token operator">+</span>top<span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> low<span class="token operator">=</span>mid<span class="token punctuation">;</span>  <span class="token comment">// low始终在ok的一块</span>    <span class="token keyword">else</span> top<span class="token operator">=</span>mid<span class="token punctuation">;</span>     <span class="token comment">// top始终在不符合的那块</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>小数二分</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">-</span>low<span class="token operator">&gt;</span>exp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>top<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>low<span class="token punctuation">)</span><span class="token punctuation">)</span> top<span class="token operator">=</span>mid<span class="token punctuation">;</span>    <span class="token keyword">else</span> low<span class="token operator">=</span>mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-高精度"><a href="#3-高精度" class="headerlink" title="3 高精度"></a>3 高精度</h3><h4 id="3-1-大数加法"><a href="#3-1-大数加法" class="headerlink" title="3.1 大数加法"></a>3.1 大数加法</h4><p>将数存在数组里面，数组倒序储存方便计算。</p><p>思想是模拟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">big_add</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t<span class="token operator">+=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t<span class="token operator">+=</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 最后一位也可能进位</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//调用</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token operator">=</span><span class="token function">big_add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>  cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-大数减法"><a href="#3-2-大数减法" class="headerlink" title="3.2 大数减法"></a>3.2 大数减法</h4><p>计算 A-B，默认 A&gt;B，如果 A&lt;B，则去计算 -(B-A).</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">big_sub</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        t<span class="token operator">+=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t<span class="token operator">-=</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 不用借位</span>        <span class="token keyword">else</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 借位</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>res<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 去前导零</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-大数乘法"><a href="#3-3-大数乘法" class="headerlink" title="3.3 大数乘法"></a>3.3 大数乘法</h4><p>一般是一个大数乘一个小数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>t<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  t<span class="token operator">+=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>b<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>res<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">// 去前导零</span>        res<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-大数除法"><a href="#3-4-大数除法" class="headerlink" title="3.4 大数除法"></a>3.4 大数除法</h4><p>一般是一个大数 ÷ 一个小数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>  <span class="token comment">// 商</span><span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 余数</span><span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> A<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>  <span class="token comment">// A 还是倒着存</span><span class="token punctuation">{</span>    y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        y<span class="token operator">=</span>y<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>y<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        y<span class="token operator">%=</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>         ans<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-压位"><a href="#3-5-压位" class="headerlink" title="3.5 压位"></a>3.5 压位</h4><p>由于数组存的数是int类型，所以只存个位数太过浪费。所以考虑将几个数合并成一位存储。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> power<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>base<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 需要同时改</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">big</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span>  <span class="token comment">// 将字符串大数转化成数组压位的大数</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> A<span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调整为个位在前</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>tem<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>w<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>power<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tem<span class="token punctuation">)</span><span class="token punctuation">;</span>  tem<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            w<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        tem<span class="token operator">+=</span>w<span class="token operator">*</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  w<span class="token operator">*=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>w<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> A<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> A<span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span> <span class="token comment">// 和普通高精一样</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">add</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A <span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> C<span class="token punctuation">;</span>    <span class="token keyword">int</span> la<span class="token operator">=</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lb<span class="token operator">=</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span>lb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>l<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> tem<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>la<span class="token punctuation">)</span> tem<span class="token operator">+=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>lb<span class="token punctuation">)</span> tem<span class="token operator">+=</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tem<span class="token operator">+</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">;</span>     <span class="token comment">// 进位</span>        C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sub</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> C<span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否有借位</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// A&gt;=B</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> tem<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>t<span class="token punctuation">;</span>  t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> tem<span class="token operator">-=</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tem<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            tem<span class="token operator">+=</span>base<span class="token punctuation">;</span> t<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>C<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> C<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 去前导零</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token operator">=</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>A<span class="token punctuation">[</span>t<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>t<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span><span class="token function">setw</span><span class="token punctuation">(</span>power<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token function">setfill</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-前缀和与差分"><a href="#4-前缀和与差分" class="headerlink" title="4 前缀和与差分"></a>4 前缀和与差分</h3><p>前缀和与差分是相反的过程。</p><h4 id="4-1-前缀和"><a href="#4-1-前缀和" class="headerlink" title="4.1 前缀和"></a>4.1 前缀和</h4><p><strong><em>可以快速求出数组某区间内的数值和</em></strong></p><p>一维数组：sum[i]=sum[i-1]+a[i]</p><p>二位数组：sum[i,j]=sum[i-1,j]+sum[i,j-1]-sum[i-1,j-1]+a[i,j]</p><h4 id="4-2-差分"><a href="#4-2-差分" class="headerlink" title="4.2 差分"></a>4.2 差分</h4><p><strong><em>可以快速处理区间同时加减一个数的问题</em></strong></p><p>一维数组：</p><p>已知数组 $a_i$ , 构造 $a_i=b_1+b_2+···+b_i$，即 b 数组前缀和是 a</p><p>通过差分构造: b[i]=a[i]-a[i-1]</p><p>在[l,r]区间加一个数 c 时：b[l]+=c,b[r+1]-=c 。</p><p>通过求前缀和得出 操作后的 a 数组。</p><p>这是离线算法，时间复杂度O(n), 树状数组是在线算法。</p><p>二维数组：</p><p>构造差分数组：b[i,j]=a[i,j]-a[i-1,j]-a[i,j-1]+a[i-1,j-1]</p><p>在(x~1~,y~1~)和(x~2~,y~2~)构成的矩形矩阵内加 c：</p><p>对差分数组操作：b[x~1~,y~1~]+=c, b[x~1~+1,y~2~+1]+=c, b[x~1~,y~2~+1]-=c, b[x~2~+1,y~1~]+=c</p><p>(后续补图)</p><p>最后通过二维数组前缀和求出改变后的数组</p><h3 id="5-离散化"><a href="#5-离散化" class="headerlink" title="5 离散化"></a>5 离散化</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">sort</span><span class="token punctuation">(</span>dif<span class="token punctuation">,</span>dif<span class="token operator">+</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 排序</span><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token function">unique</span><span class="token punctuation">(</span>dif<span class="token punctuation">,</span>dif<span class="token operator">+</span>cnt<span class="token punctuation">)</span><span class="token operator">-</span>dif<span class="token punctuation">;</span>   <span class="token comment">// 去重，m 返回不重复的数</span><span class="token keyword">int</span> p<span class="token operator">=</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>dif<span class="token punctuation">,</span>dif<span class="token operator">+</span>m<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token operator">-</span>dif<span class="token punctuation">;</span>  <span class="token comment">// 二分取离散化后 x 映射的位置，后面就用这个位置 p 代表 x 了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h2><h3 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h3><p><strong>单链表</strong></p><p>结构体形式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组模拟单链表: 用邻接表,可以用来存图和树</p><ul><li><p>head：头结点的下标，初始为 -1</p></li><li><p>e[N]：结构体中的 val，e[i] 表示结点 i 的值</p></li><li><p>ne[N]：结构体中的 next 指针，ne[i]表示结点 i 的next指针</p></li><li><p>idx：下表索引，第 idx 个插入链表的</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> head<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token comment">// 添加值为 x 的结点,头插法</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>head<span class="token punctuation">;</span>    head<span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">add_k</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  <span class="token comment">// 插入下表为k的后面</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    n<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dele_k</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token comment">// 将下标为k的后面那个点删去</span><span class="token punctuation">{</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>ne<span class="token punctuation">[</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双链表</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    node <span class="token operator">*</span>nextL<span class="token punctuation">,</span><span class="token operator">*</span>nextR<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组模拟双链表</p><p>l[i],r[i] 表示 结点 i 的左右指针</p><p>0 表示左端点，1 表示右端点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>l<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">;</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  idx<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化，互相指</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token comment">// 下表是 k 的右边插入 x</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    r<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 新点右指针指向右边的点</span>    l<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>      <span class="token comment">// 新点的左指针指向 k</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token punctuation">;</span>  <span class="token comment">// 右边的做指针指向新插入的点</span>    r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// k 的右指针指向新插入的点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span>  <span class="token comment">// 删去下表为 k 的点</span><span class="token punctuation">{</span>    r<span class="token punctuation">[</span>l<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>l<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-模拟栈和队列"><a href="#2-模拟栈和队列" class="headerlink" title="2 模拟栈和队列"></a>2 模拟栈和队列</h3><p>先进后出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>  <span class="token comment">// 插入</span>tt<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">//弹出</span>tt<span class="token operator">&gt;</span><span class="token number">0</span>   <span class="token comment">//不空,否则是空的</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span>  <span class="token comment">// 是栈顶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈的应用：表达式求值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1000005</span><span class="token punctuation">;</span><span class="token comment">// 中序遍历</span><span class="token keyword">int</span> stk1<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>tt1<span class="token punctuation">;</span><span class="token keyword">char</span> stk2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 栈里的运算符运算级是递增的</span><span class="token keyword">int</span> tt2<span class="token punctuation">;</span> <span class="token comment">// 还可以加新的运算符</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mp<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'-'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'*'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 从后往前运算</span>    <span class="token keyword">int</span> a<span class="token operator">=</span>stk1<span class="token punctuation">[</span>tt1<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 运算符后面的数</span>    <span class="token keyword">int</span> b<span class="token operator">=</span>stk1<span class="token punctuation">[</span>tt1<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 运算符前面的数</span>    <span class="token keyword">char</span> c<span class="token operator">=</span>stk2<span class="token punctuation">[</span>tt2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'+'</span><span class="token punctuation">)</span> res<span class="token operator">=</span>b<span class="token operator">+</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span>  res<span class="token operator">=</span>b<span class="token operator">-</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'*'</span><span class="token punctuation">)</span>  res<span class="token operator">=</span>b<span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span> res<span class="token operator">=</span>b<span class="token operator">/</span>a<span class="token punctuation">;</span>    stk1<span class="token punctuation">[</span><span class="token operator">++</span>tt1<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                t<span class="token operator">=</span>t<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>s<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stk1<span class="token punctuation">[</span><span class="token operator">++</span>tt1<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>            i<span class="token operator">=</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span><span class="token punctuation">)</span> stk2<span class="token punctuation">[</span><span class="token operator">++</span>tt2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'('</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">')'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>stk2<span class="token punctuation">[</span>tt2<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'('</span><span class="token punctuation">)</span>  <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tt2<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 弹出左括号</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>  <span class="token comment">// 除括号数字以外的运算符</span>        <span class="token punctuation">{</span>            <span class="token comment">// 当前运算符小于栈顶，说明左右子树都遍历完了，此时可以计算出前面的值</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>tt2<span class="token operator">&amp;&amp;</span>mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>mp<span class="token punctuation">[</span>stk2<span class="token punctuation">[</span>tt2<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stk2<span class="token punctuation">[</span><span class="token operator">++</span>tt2<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tt2<span class="token punctuation">)</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>stk1<span class="token punctuation">[</span>tt1<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先进先出  $\gets $hh <em> </em> <em> </em> tt$\gets$，从 tt 处加，从 hh 处出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>hh<span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// hh 是队头，tt是队尾</span>q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>  <span class="token comment">// 插入队列</span>hh<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 弹出</span>hh<span class="token operator">&lt;=</span>tt  <span class="token comment">// 不空 否则是空的</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span>  <span class="token comment">// 队头</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span>  <span class="token comment">// 队尾</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-单调栈和单调队列"><a href="#3-单调栈和单调队列" class="headerlink" title="3 单调栈和单调队列"></a>3 单调栈和单调队列</h3><p><strong>单调栈</strong>：栈内的元素是具有单调性的</p><p>应用于：找数组中一个数的左边或者右边第一个比它大或者小的数</p><p>例题：<a href="https://www.acwing.com/problem/content/832/">单调栈</a> 给定N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100005</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>tt<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">;</span>   cin<span class="token operator">&gt;&gt;</span>x<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">&lt;=</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>tt<span class="token punctuation">)</span>             tt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">// 弹出栈内比当前元素大的，保证栈的单调递增的</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tt<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单调队列</strong>：队列元素是单调的，是双端队列</p><p>应用于<strong>滑动窗口</strong>求最值</p><p>例：<a href="https://www.acwing.com/problem/content/156/">滑动窗口</a>，求窗口大小为 k 的最大和最小值</p><p>维护两个单调队列</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 求最小值模板</span><span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>hh<span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 队列保存下标</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">;</span><span class="token comment">// 维护单调性，将队列里后面的大于当前数的删去，去尾</span><span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt1<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>hh<span class="token operator">&lt;=</span>tt<span class="token punctuation">)</span> tt<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">// 删头,与 i 距离超过 k 的要删去</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token operator">&gt;=</span>k<span class="token operator">&amp;&amp;</span>hh<span class="token operator">&lt;=</span>tt<span class="token punctuation">)</span> hh<span class="token operator">++</span><span class="token punctuation">;</span>q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  <span class="token comment">// 将该元素入队</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;=</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  ans<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存入答案</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-KMP"><a href="#4-KMP" class="headerlink" title="4 KMP"></a>4 KMP</h3><p>next[i]: 含义是以 i 为终点的最长后缀，从下标 0 开始，next[0]=-1，next[1]=0</p><p>字符串 p 的 next 值跟当前位无关，所以第 i 位匹配相等时 next[i+1]=j+1, 简写位 next[++i]=++j </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> nxt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// p 要回退的位置</span><span class="token keyword">void</span> <span class="token function">get_next</span><span class="token punctuation">(</span>string p<span class="token punctuation">)</span>  <span class="token comment">// 求模式串next</span><span class="token punctuation">{</span>    nxt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// i 为正在匹配的字符的位置，j 表示后缀长度</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>   nxt<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">++</span>j<span class="token punctuation">;</span> <span class="token comment">// 相等，后缀长度++</span>        <span class="token keyword">else</span>  j<span class="token operator">=</span>nxt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 回退了j,寻找更小的最大后缀</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// s是长串，p 是短串是已知next的串</span><span class="token keyword">void</span> <span class="token function">kmp</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span>string p<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sl<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>pl<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>sl<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 当前匹配成功，都往后移一位</span>            i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>  j<span class="token operator">=</span>nxt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 匹配失败往前退，相当于向左挪短的串 </span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">-</span>j<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">//输出匹配成功的起始下标</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 调用</span><span class="token function">get_next</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">kmp</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-Trie树"><a href="#5-Trie树" class="headerlink" title="5 Trie树"></a>5 Trie树</h3><p>是一个能高效地存储和查找字符串集合的数据结构</p><p>建立树，就是向一个集合添加字符串的过程</p><p>查找字符串的数量和建立树类似</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/Trie%E6%A0%91.jpg" alt="img"></p><p><a href="https://www.acwing.com/problem/content/837/">模板题</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> son<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前结点的儿子，儿子最多有26个，因为小写字母只有26个</span><span class="token keyword">int</span> cnt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 打标记，以第 i 字母结尾的字符串的个数</span><span class="token keyword">int</span> idx<span class="token punctuation">;</span>       <span class="token comment">// 初始化为0，根结点是0</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 从根结点开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// p 下不存在儿子 u</span>            son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">++</span>idx<span class="token punctuation">;</span>        p<span class="token operator">=</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 往下走</span>    <span class="token punctuation">}</span>    cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 个数+1</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 从根结点开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Trie 另一个应用：存储二进制数</p><p><a href="https://www.acwing.com/problem/content/145/">最大异或对</a></p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111151404479.jpg" alt="img"></p><h3 id="6-并查集"><a href="#6-并查集" class="headerlink" title="6 并查集"></a>6 并查集</h3><p>将两个集合合并； 询问两个元素是否在同一个集合中</p><p>基础并查集：<a href="https://www.acwing.com/problem/content/838/">模题合并集合</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>   <span class="token comment">// 初始化 p 数组，自成一派</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>  <span class="token comment">// 返回 x 祖宗结点并路径压缩</span><span class="token punctuation">{</span><span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token operator">?</span>x<span class="token operator">:</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token comment">// 合并集合</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> u<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>拓展应用：</strong> 维护并查集附加信息</p><p><a href="https://www.acwing.com/problem/content/839/">连通块数量</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 实时查询某元素所在集合中元素的数量</span><span class="token comment">// 在合并时记录，只维护根结点对应的 cnt</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> u<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">!=</span>v<span class="token punctuation">)</span>      <span class="token punctuation">{</span>        p<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>    <span class="token comment">// 将祖宗为 u 所在的集合合并到 v 所在的集合</span>        cnt<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">+=</span>cnt<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 祖宗 v 的数量增加了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拓展应用：维护当前点到根结点的距离</p><p><a href="https://www.acwing.com/problem/content/description/242/">食物链</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">50005</span><span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>ans<span class="token punctuation">,</span>dis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> fa <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> dis<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> fa<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> f<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>f<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&gt;</span>n<span class="token operator">||</span>b<span class="token operator">&gt;</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>ans<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span>dis<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span> ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>y<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>                dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span>dis<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span> ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">-</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>y<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>                dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">-</span>dis<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-堆"><a href="#7-堆" class="headerlink" title="7 堆"></a>7 堆</h3><p>堆是一棵完全二叉树，顶点取最值</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E5%A0%86.png" alt=""></p><p>由于编号为 i 的父结点的左结点为 2i，右结点为 2i+1，所以用保存堆。</p><p>以小根堆为例</p><p><strong>down操作</strong>：把一个大数往下移</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111151426489.jpg" alt="img"></p><p><strong>UP操作</strong>：把一个较小的数往上移</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111151431092.jpg" alt="img"></p><blockquote><p>维护一个数组集合, heap[size]表示最后一个，heap[1]表示第一个即堆顶</p><ul><li>插入一个数         heap[++size]=x; up(size);</li><li>求集合中的最小值    heap[1];</li><li>删除集合中的最小值  heap[1]=heap[size]; size—; down(1);</li><li>删除任意一个数      heap[k]=heap[size]; size—; down(k); up(k);</li><li>修改任意一个元素    heap[k]=x; down(k); up(k);</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><span class="token comment">// ph[k]存储第k个插入的点在堆中的位置</span><span class="token comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><span class="token comment">// ph[k]=j, hp[j]=k, 二者是相反的</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>ph<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>hp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">heap_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span>ph<span class="token punctuation">[</span>hp<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>ph<span class="token punctuation">[</span>hp<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>hp<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span>hp<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span>h<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> t<span class="token operator">=</span>u<span class="token punctuation">;</span>  <span class="token comment">// t 表示值最小的编号</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>u <span class="token operator">&lt;=</span> idx <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 判断左儿子</span>        t<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> idx <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 判断右儿子</span>        t <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u <span class="token operator">!=</span> t<span class="token punctuation">)</span>  <span class="token comment">// t 不是本身，即 u 与两个儿子相比不是最小的</span>    <span class="token punctuation">{</span>        <span class="token function">heap_swap</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>u<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>u<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">heap_swap</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> u<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        u <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 最后一层不用down</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token function">down</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 建堆 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆的应用：<strong>堆排序</strong> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">100005</span><span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token operator">=</span>u<span class="token punctuation">;</span>   <span class="token comment">// 三个点的最小值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>u <span class="token operator">&lt;=</span> idx <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> t<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> idx <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> t<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>u<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">!=</span>u<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span>h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    idx<span class="token operator">=</span>n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">down</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>m <span class="token operator">--</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        h<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>h<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span> idx<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 取出堆顶</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-哈希表"><a href="#8-哈希表" class="headerlink" title="8 哈希表"></a>8 哈希表</h3><p>储存结构：开放寻址法，拉链法。</p><p><strong>拉链法</strong>：将大数取模，将相同模的组成一个链表</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">%</span>mod<span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span> <span class="token comment">// mod 要选一个质数使得链尽可能短</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// h[k] 表示头结点</span>    h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">%</span>mod<span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 在链中寻找</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开放寻址法</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">1e5</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span>inf<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    mod<span class="token operator">=</span><span class="token number">200003</span><span class="token punctuation">;</span> <span class="token comment">// mod 选小于 N 但尽量大的质数</span><span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">%</span>mod<span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">!=</span>inf <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span>N<span class="token punctuation">)</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 后面用完了，从起点重新找位置</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span>  <span class="token comment">// 存在则返回 k 的下标，不存在则返回一个空的下标</span><span class="token punctuation">}</span><span class="token comment">// 调用</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>op<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'I'</span><span class="token punctuation">)</span>  h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span><span class="token function">query</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">!=</span>inf<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Yes\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字符串哈希</strong>：把一个字符串变成一个 p 进制数字，实现不同的字符串映射到不同的数字，即不同点字符串有不同的哈希值。。</p><p>对形如 $ c_1c_2c_3···c_{n-1}c_n $ 的字符串，采用Ascii码乘 P 的次方来计算哈希值。映射公式为：</p><script type="math/tex; mode=display">(A_1\times P^{n-1}+A_2\times P^{n-2}+···+A_{n-1}\times P^1+X_n\times P^0)\ \ mod\ \ Q\\Q=2^{64}</script><p>对一个字符串求哈希值：h[i+1]=h[i]*P+s[i]</p><p>某段字符串的哈希值: h[l,r]=h[r]-h[l-1]*P^r-l+1^ </p><p>区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，<br>乘上 P^2^ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p><p>模板题：<a href="https://www.acwing.com/problem/content/843/">字符串哈希</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ull<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> P<span class="token operator">=</span><span class="token number">131</span><span class="token punctuation">;</span> <span class="token comment">//P 取131或13331，经验值</span>ull h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 前i 字符串的哈希值</span>ull p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>q<span class="token punctuation">;</span><span class="token keyword">char</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>ull <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> h<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>h<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>p<span class="token punctuation">[</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>q<span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 要从 1 开始</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>P<span class="token punctuation">;</span>        h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>h<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>P<span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串变成了 P进制数</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> l1<span class="token punctuation">,</span>r1<span class="token punctuation">,</span>l2<span class="token punctuation">,</span>r2<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>l1<span class="token punctuation">,</span><span class="token operator">&amp;</span>r1<span class="token punctuation">,</span><span class="token operator">&amp;</span>l2<span class="token punctuation">,</span><span class="token operator">&amp;</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span>r1<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">get</span><span class="token punctuation">(</span>l2<span class="token punctuation">,</span>r2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Yes\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三章-搜索与图论"><a href="#第三章-搜索与图论" class="headerlink" title="第三章 搜索与图论"></a>第三章 搜索与图论</h2><h3 id="1-存图方式"><a href="#1-存图方式" class="headerlink" title="1 存图方式"></a>1 存图方式</h3><h4 id="1-1-vector存图"><a href="#1-1-vector存图" class="headerlink" title="1.1 vector存图"></a>1.1 vector存图</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> G<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加边</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> y<span class="token operator">=</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 遍历边 x-&gt;y</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点</span><span class="token comment">// h[k] 存储这个单链表的头结点</span><span class="token comment">// e[k] 一条边的终点</span><span class="token comment">// w[k] 存储边的权值</span><span class="token comment">// ne[k] 表示下一个点的下标，next指针</span><span class="token comment">// idx 存储结点编号</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token comment">// 添加一条边a-&gt;b，权值为c，头插法</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx <span class="token operator">++</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// dfs遍历</span><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    st<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// st[u] 表示点u已经被遍历过</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 找以 u 为起点的边</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 这条边的起点为 u ，终点为 j</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// bfs遍历</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// 表示1号点已经被遍历过</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// 表示点j已经被遍历过</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 初始化</span>idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2 DFS"></a>2 DFS</h3><p>n个数的全排列：<a href="https://www.acwing.com/problem/content/844/">排列数字</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    ans<span class="token punctuation">[</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-BFS"><a href="#3-BFS" class="headerlink" title="3 BFS"></a>3 BFS</h3><h3 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4 拓扑排序"></a>4 拓扑排序</h3><p>记录入度，依次删度为0的点</p><h3 id="5-最短路"><a href="#5-最短路" class="headerlink" title="5 最短路"></a>5 最短路</h3><h4 id="5-1-Dijkstra"><a href="#5-1-Dijkstra" class="headerlink" title="5.1 Dijkstra"></a>5.1 Dijkstra</h4><p>Dijkstra朴素版：时间复杂度$ O(n^2) $ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> g<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储每条边</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储1号点到每个点的最短距离</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 存储每个点的最短路是否已经确定</span><span class="token comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><span class="token keyword">int</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 在还未确定最短路的点中，寻找距离源点最小的点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">&gt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                t <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token comment">// 用t更新其他点的距离</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>堆优化版Dijkstra</strong> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 结构体优先队列</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    bool operator <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> node <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token comment">// 小顶堆</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> w <span class="token operator">&gt;</span> t<span class="token punctuation">.</span>w<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>priority_queue<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> q<span class="token punctuation">;</span><span class="token comment">// pair 优先队列，先比较 first</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> piipriority_queue<span class="token operator">&lt;</span>pii<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pii <span class="token operator">&gt;</span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span>pii <span class="token operator">&gt;</span> <span class="token operator">&gt;</span> q<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>z<span class="token punctuation">;</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    priority_queue<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span>ww<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//if(st[u]) continue;   st[u]=1;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">!=</span>ww<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 两种方法节约时间</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> v<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">&gt;</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>v<span class="token punctuation">,</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-Bellman-Ford"><a href="#5-2-Bellman-Ford" class="headerlink" title="5.2 Bellman-Ford"></a>5.2 Bellman-Ford</h4><p>求最多经过 k 条边能到达的最短路   O(nm)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Edge</span>  <span class="token comment">// 结构体直接存图</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>  <span class="token comment">//a -&gt; b</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span>  <span class="token punctuation">}</span>edge<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>back<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// back 为备份的上一次 dis 数组</span><span class="token keyword">void</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>back<span class="token punctuation">,</span>dis<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> a<span class="token operator">=</span>edge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span>e<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span>w<span class="token operator">=</span>e<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span>back<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用back更新</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">&gt;</span>inf<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">// 因为存在负权，inf可能被更新，不连通</span><span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span>dis<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-SPFA"><a href="#5-3-SPFA" class="headerlink" title="5.3 SPFA"></a>5.3 SPFA</h4><p>用于求带负权的最短路、求负环  O(m) 到 O(nm)</p><p>对BellmanFord的优化，用队列储存是否有必要更新</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> dis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 储存是否遍历过</span><span class="token keyword">void</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dis<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 被更新的才有机会更新别人</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 代表 x 曾被更新，但还能被继续更新</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&gt;</span>dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dis<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// y 被更新了，所以可以用它更新其他的</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断是否存在<strong>负环</strong> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> cnt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录 i 的最短路边数，边数大于等于 n 说明存在负环</span>bool <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//有些点跟负环可能不连通，所以要全入队 </span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&gt;</span>dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dis<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                cnt<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&gt;=</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>  <span class="token comment">// 存在负环</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-Floyd"><a href="#5-4-Floyd" class="headerlink" title="5.4 Floyd"></a>5.4 Floyd</h4><p>用于多源最短路</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// 记得先枚举中间点</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-最小生成树-MST"><a href="#6-最小生成树-MST" class="headerlink" title="6 最小生成树 MST"></a>6 最小生成树 MST</h3><h4 id="6-1-Prim"><a href="#6-1-Prim" class="headerlink" title="6.1 Prim"></a>6.1 Prim</h4><p>寻找离集合最近的点 t，加入集合，然后用 t 更新其他未在集合的点离集合的距离。 时间复杂度 $O(n^2)$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> dis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 距离集合最近的距离</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 标记是否在集合中</span><span class="token keyword">int</span> mp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始化为 inf</span><span class="token keyword">void</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>mp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 设最初集合只有 1</span>    st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// n-1 次循环</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> t<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 寻找不在集合且距离集合最近的点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>dis<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">&gt;</span>dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                t<span class="token operator">=</span>j<span class="token punctuation">;</span>        ans<span class="token operator">+=</span>dis<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 将点 t 加入集合</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment">// 更新点到集合的距离</span>            dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>mp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&gt;</span>inf<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-Kruskal"><a href="#6-2-Kruskal" class="headerlink" title="6.2 Kruskal"></a>6.2 Kruskal</h4><p>先将权值边排序，选择端点不在同一集合的边并将两个端点加入集合，直到选择 $n-1$ 条边。若选不到 n-1 条边，说明没有mst</p><p>时间复杂度 $O(mlogn)$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">;</span><span class="token punctuation">}</span>edge<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>bool <span class="token function">cmp</span><span class="token punctuation">(</span>Edge x<span class="token punctuation">,</span>Edge y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>w<span class="token operator">&lt;</span>y<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span>edge<span class="token operator">+</span>m<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// 枚举边</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token operator">=</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>u<span class="token punctuation">,</span>b<span class="token operator">=</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>        <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>y<span class="token punctuation">)</span>   <span class="token comment">// 用并查集判断两个点是否在同一集合</span>        <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>            ans<span class="token operator">+=</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-二分图"><a href="#7-二分图" class="headerlink" title="7 二分图"></a>7 二分图</h3><p>定义：无向图 $G=(V,E)$ 中顶点可以被分为两个不相交集合 A 和 B，并且 E 都是跨越组的形式。也就是说一条边的两个顶点不会在同一个集合。</p><blockquote><p>定理：一个图是二分图，当且仅当图中不含奇数环。</p><p>必要性证明：设奇数环 A-&gt;B-&gt;C-&gt;A</p><p>​    所以 AB，BC，CA 不在同一个集合，显然两个集合无法共存</p><p>​    所以二分图不含奇数环</p><p>必要性证明：可以构造出一个二分图</p></blockquote><p>必要性：由已知推出结论</p><p>充分性：由结论推出已知</p><h4 id="7-1-搜索染色染色法"><a href="#7-1-搜索染色染色法" class="headerlink" title="7.1 搜索染色染色法"></a>7.1 搜索染色染色法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 将二分图的两个集合一个染 1，一个染 2</span>bool <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token comment">// x 染 c 色</span><span class="token punctuation">{</span>    co<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>co<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 变的两端颜色相同</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>co<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">-</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 无向边</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 二分图不一定是连通的，所以要对每个点dfs</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>co<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"No"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Yes"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-匈牙利算法"><a href="#7-2-匈牙利算法" class="headerlink" title="7.2 匈牙利算法"></a>7.2 匈牙利算法</h4><p>求二分图的最大匹配。</p><p>匈牙利时间复杂度：最坏是 $O(nm)$ ，但一般远小于。</p><p>是一个寻找最长增广路的过程</p><blockquote><p><strong>二分图的匹配</strong>：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>通俗的理解：二分图的一个集合是男生，另一个集合是女生，求能凑成最多情侣的对数。</p><p><strong>完美匹配</strong>：覆盖图中所有点的匹配。全部结成对，没有剩余</p><p><strong>二分图的最大匹配</strong>：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><p><a href="https://www.acwing.com/problem/content/863/">二分图的最大匹配</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pii<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">505</span><span class="token punctuation">,</span>M<span class="token operator">=</span><span class="token number">100005</span><span class="token punctuation">,</span>inf<span class="token operator">=</span><span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span>n2<span class="token punctuation">,</span>m<span class="token punctuation">,</span>ans<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>e<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>ne<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">;</span><span class="token keyword">int</span> match<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 右边女孩 i 已经匹配到左边的 match[i] 了</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">;</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 还有机会选择 y</span>        <span class="token punctuation">{</span>            st<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 标记已经尝试了，这次不行的话注定无缘</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span><span class="token function">find</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                match<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>   <span class="token comment">// x 与 y 匹配成功</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n1<span class="token punctuation">,</span><span class="token operator">&amp;</span>n2<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 只存一条边</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右边每个都有机会与之结对</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>  ans<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四章-数学"><a href="#第四章-数学" class="headerlink" title="第四章 数学"></a>第四章 数学</h2><h3 id="1-基础数学"><a href="#1-基础数学" class="headerlink" title="1 基础数学"></a>1 基础数学</h3><h4 id="1-1质数"><a href="#1-1质数" class="headerlink" title="1.1质数"></a>1.1质数</h4><p>只能被 1 和本身整除的数。1 不是质数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 判断是否为质数</span>bool <span class="token function">is_prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 分解质因数</span><span class="token keyword">void</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>x<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> s<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                x<span class="token operator">/=</span>i<span class="token punctuation">;</span>  s<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1 %d"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>质数筛: 求[1,n]的质数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 埃氏筛 nloglogn</span>bool p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// p[i]=1 说明不是质数</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// p[i]==0 说明 i 是质数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">+=</span>i<span class="token punctuation">)</span>                p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 线性筛, n 只会被最小质因子筛掉</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 从小到大枚举质数</span>        <span class="token punctuation">{</span>            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 只会用最小质因子去筛</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 当枚举到 i 的最小质因子时退出，因为 i×p[j+t]的最小质因子是p[j]</span><span class="token comment">// i%pj == 0, pj定为i最小质因子，pj也定为pj*i最小质因子</span><span class="token comment">// i%pj != 0, pj定小于i的所有质因子，所以pj也为pj*i最小质因子</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合数一定能被线性筛筛掉：因为合数=p*k,p 是最小质因子，当枚举质数到 i=k 时，就被筛掉了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里不能去掉等号，当去掉等号会误筛掉很多 n 附近的合数。</p><h4 id="1-2-因数（约数）"><a href="#1-2-因数（约数）" class="headerlink" title="1.2 因数（约数）"></a>1.2 因数（约数）</h4><p>==约数个数==   ==约数之和== </p><blockquote><p>约数个数定理: 对于一个大于 1 的正整数 n 可以分解质因数</p><script type="math/tex; mode=display">n\ =\ \prod_{i=1}^{k} p_i^{a_i}=p_1^{a_1}·p_1^{a_1}····p_k^{a_k}\\p_1,p_2···p_k为 n 的质因子</script><p>约数的个数：$ f(n)=\prod_{i=1}^{k} (a_i+1) $  </p><p>约数的和：</p><script type="math/tex; mode=display">s(n)=\prod_{i=1}^{k} \sum_{j=0}^{a_i} p_i^j=(p_1^0+p_1^1+···+p_1^{a_1})\times ···\times (p_k^0+p_k^1+···+p_k^{a_k})</script></blockquote><p>==最大公约数 gcd== </p><p>d|a 且 d|b, 那么 d|(ax+by)</p><p>整除符号: |, 若 d|a 等价于 a=kd, k 为整数</p><blockquote><p><strong>欧几里得算法</strong>：$gcd(a,b)=gcd(b,a\ \%\  b)$  <span id="oujilide"> </span> </p><p>证明：不妨设 $a&gt;b&gt;0$，有 $a=k·b+r,\ \ k=\left \lfloor \frac{a}{b} \right \rfloor\ ,\ \ r=a\%b $ </p><p>如果 $r=0$, gcd(a,b)=gcd(b,0)=b</p><p>如果 $r\ne 0$, $r=a-k·b,\ \ 左右同除\ d\ ,得 \frac{r}{d}=\frac{a}{d}-\frac{k·b}{d}=m$,显然 m 是整数，所以 d|r, 即d|(a%b)。</p><p>假设 d 是 （b，a%b) 的任意一个公约数，a=yd+kb，两边同除 d 得 $\frac{a}{d}=y+\frac{kb}{d}$，所以 y 为正整数，d也是（a，b）的公约数。</p><p>所以 (a, b)和(b, a%b) 的公约数是一样的，自然最大公约数也一样。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 辗转相除法</span><span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>  <span class="token comment">// b==0 输出</span><span class="token punctuation">}</span><span class="token comment">// STL函数</span>c <span class="token operator">=</span> <span class="token function">__gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==求 n 以内的含有最多因子的数== （$n\le10^{18}$） </p><p>一个数的因子可以由多个质数相乘得到，由于 n 的范围。</p><blockquote><p>两个个数有相同数量的质因子，当最大质因子越大，因子数不会变多</p><p>证明：设两个数位为 $n$ 和 $m$，最大质因子为 $p_{nk}$&gt;$p_{nk}$。</p><p>质因子分解： $ n = p_1^{a_1}p_2^{a_2}···p_k^{a_k}$  </p><p>因数个数 $ f(n)=\prod_{i=1}^{k} (a_i+1) $   </p><p>所以，质因子应该越小越好。所以选取前 k 个质数，且质数乘积小于等于 n。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 选取前 15 个质数就够了，前 16 个质数乘积大于 1e18</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">,</span><span class="token number">51</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// sum 表数当前乘积，res表示当前因数个数，last表示前一个质数的指数</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> now<span class="token punctuation">,</span>ll sum<span class="token punctuation">,</span><span class="token keyword">int</span> res<span class="token punctuation">,</span><span class="token keyword">int</span> last<span class="token punctuation">)</span><span class="token punctuation">{</span>    ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">&gt;=</span><span class="token number">15</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 不选择当前质数就更不可能选后面的质数，结束搜索</span>    <span class="token comment">// 选 i 次 p[now]。选择的个数要小于上一个质数选择的个数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>last<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&gt;</span>n<span class="token operator">/</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 不能写成 sum*p[now]，会超精度</span>        sum<span class="token operator">*=</span>p<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>res<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>now<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>sum<span class="token punctuation">,</span>t<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-欧拉函数"><a href="#2-欧拉函数" class="headerlink" title="2 欧拉函数"></a>2 欧拉函数</h3><blockquote><p>phi(n)为 [1,n] 中与 n 互质的个数</p><p>n 的 质因子分解为 $ n = p_1^{a_1}p_2^{a_2}···p_k^{a_k}$ </p><p>那么 $phi(n)=n\times (1-\frac{1}{p_1})(1-\frac{1}{p_2})···(1-\frac{1}{p_k})$ </p><p>证明1（容斥原理）：</p><script type="math/tex; mode=display">phi(n)=n-\frac{n}{p_1}-\frac{n}{p_2}-···-\frac{n}{p_k}+\frac{n}{p_1p_2}+\frac{n}{p_1p_3}+···\\(分母为奇数个p为减，偶数个p为加)\\=n\times (1-\frac{1}{p_1})(1-\frac{1}{p_2})···(1-\frac{1}{p_k})</script></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 欧拉函数</span><span class="token keyword">int</span> <span class="token function">phi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res<span class="token operator">=</span>n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token operator">=</span>res<span class="token operator">/</span>i<span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> n<span class="token operator">/=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span>res<span class="token operator">/</span>n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 欧拉筛</span><span class="token keyword">int</span> phi<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">phis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    phi<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            prime<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>            phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>n<span class="token operator">/</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            st<span class="token punctuation">[</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                phi<span class="token punctuation">[</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span>phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            phi<span class="token punctuation">[</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">=</span>phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>· 质数除了自己，其他都互质，所以 phi[i]=i-1;</p><p>· 当 i%prime[j]==0，p~j~ 是 i 的最小质因子，所以 i 的分解质因子里有 p~j~，因为欧拉函数和质因子指数无关，改变的只是前面的系数，所以 phi[i×p~j~]=i×p~j~×phi[i]</p><p>· 当 i%prime[j]!=0，i×p~j~ 比 i 的质因子多了 p~j~，所以</p><p>phi[i×p~j~]=phi[i]×p~j~×(1-1/p~j~)=phi[i]×(p~j~-1)</p><blockquote><p><strong>欧拉定理</strong>：a 与 n 互质，则有</p><script type="math/tex; mode=display">a^{phi(n)}\equiv 1\ (mod\ n)</script><p>证明：[1,n]中所有与 n 互质的数为 $a_1,a_2,···，a_{phi(n)}$，那么$a<em>a_1 \% n,a</em>a_2\% n,···，a*a_{phi(n)}\%n$ 也是[1,n]中与 n 互质的数</p><p>所以两列数除顺序外相同，所以相乘相等 $a^{phi(n)}<em>(a_1</em>a_2<em>···</em>a_{phi(n)})\%n=a_1<em>a_2</em>···*a_{phi(n)}$</p><p>化简得 $a^{phi(n)}\equiv 1(mod\ n)$ 得证</p><p>a % n = b 和 a $\equiv$ b (mod n)是等价的</p><p><strong>费马小定理</strong>：p 是质数且 a 与 p 互质，则有</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\ (mod\ n)</script></blockquote><h3 id="3-快速幂"><a href="#3-快速幂" class="headerlink" title="3 快速幂"></a>3 快速幂</h3><p>求 $a^k\ \%\ mod$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">qpow</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>base<span class="token operator">=</span>a<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">=</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>res<span class="token operator">*</span>base<span class="token operator">%</span>mod<span class="token punctuation">;</span>        base<span class="token operator">=</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>base<span class="token operator">*</span>base<span class="token operator">%</span>mod<span class="token punctuation">;</span>        k<span class="token operator">&gt;&gt;=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>矩阵快速幂：</p><h3 id="4-扩展欧几里得"><a href="#4-扩展欧几里得" class="headerlink" title="4 扩展欧几里得"></a>4 扩展欧几里得</h3><blockquote><p>==裴属定理==：若 a, b 是整数, 且 gcd(a,b) = d，那么对于任意的整数 x、y, <strong>ax + by</strong> 都一定是 d 的倍数，特别地，一定存在整数 x，y，使 ax+by=d 成立，即 $ax+by=kd\ \ (k\ge 1)$ 。</p><p>证明：懒得证</p><p>d|a 且 d|b, 所以 d|ax 且 d|by, 所以 d|(ax+by) </p><p>==推论==：</p><ol><li>对于方程 ax+by=1，只有当整数a,b互质时，方程才有整数解</li><li>a，b互质的充要条件是 ax+by=1 有整数解 </li></ol><p>证明1：假设 a，b不互质，则a，b可以表示为 $a=q\times d$, $b=p\times d$ 。代入上式得</p><script type="math/tex; mode=display">q\times d \times x+p\times d \times y=1\\q\times x+p\times y=\frac{1}{d}\\d=gcd(a,b)\ne 1\\</script><p>所以该方程右边为小数，不存在整数解。</p><p>扩展欧几里得求 ax+by=d 的一组解的证明</p><p>当 $b=0$，式子转化为 $ax+by=a$，所以 x=1，y=0</p><p>当 $b\ne 0$，由<a href="#oujilide">欧几里得算法</a> gcd(a,b)=gcd(b,a%b)</p><script type="math/tex; mode=display">ax+by = gcd(a,b)=gcd(b,\ a\ \%\ b)\\=bx'+(a\ \%\ b)y' \\=bx'+(a-b*\left \lfloor \frac{a}{b}  \right \rfloor )y'\\=ay'+b(x'-\left \lfloor \frac{a}{b}  \right \rfloor y')\\比较等式两边可知\ x=y'\ \ \ y=x'-\left \lfloor \frac{a}{b}  \right \rfloor y'</script><script type="math/tex; mode=display">\begin{flalign*}&通解: \begin{cases}  &  x=x_0+k\frac{b}{d} \\  &  y=y_0-k\frac{a}{d}\end{cases}\\证明: &\ \ 将其代回原式， a(x_0+k\frac{b}{d})+b(y_0-k\frac{a}{d})=m\\&\ \ 展开得\ \  ax_0+by_0=m ,含有\ k\ 的被消去了\\&\ \ 得到的式子和原式一样，证毕&\end{flalign*}</script></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 伴随着欧几里得算法更新 x y 的过程</span><span class="token keyword">void</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>  x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> t<span class="token operator">=</span>x<span class="token punctuation">;</span>  x<span class="token operator">=</span>y<span class="token punctuation">;</span>        y<span class="token operator">=</span>t<span class="token operator">-</span>a<span class="token operator">/</span>b<span class="token operator">*</span>y<span class="token punctuation">;</span>   <span class="token comment">// 对应上面的证明</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 省代码</span><span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">,</span>y<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调换 x y</span>    y<span class="token operator">-=</span>a<span class="token operator">/</span>b<span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">return</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exgcd应用：求解线性同余方程 <span id="linear congruent equation"> </span>  </p><script type="math/tex; mode=display">&ax\equiv\ b\ \ \ (mod\ \ m)\\\Longleftrightarrow & ax\ \%\ m=b\\\Longleftrightarrow & ax=my+b\\\Longleftrightarrow & ax-my=b \\\Longleftrightarrow & ax+my'=b\\\Longleftrightarrow & 给定a,b,m\ \  求 x\\& 所以如果b=k·gcd(a,m)才有解\\& 解为 gcd(a,m)/b*x\%m</script><blockquote><p>答案对 m 取模仍为答案</p><p>$ax\ \%\ m=b\Longleftrightarrow\ a·(x\ \%\ m)\ \%\ m=b$ </p><p>所以对 x % m仍是个答案</p></blockquote><h3 id="5-逆元"><a href="#5-逆元" class="headerlink" title="5 逆元"></a>5 逆元</h3><p>$ \frac{a}{b}\equiv a\times x \%\ m $，x 就是 b 的逆元</p><h5 id="5-1-快速幂求逆元"><a href="#5-1-快速幂求逆元" class="headerlink" title="5.1 快速幂求逆元"></a>5.1 快速幂求逆元</h5><p>要求模数 m 为质数。<br>b 存在乘法逆元的充要条件是 <strong>b 与模数 m 互质</strong> 。</p><blockquote><p>​    当 b 与 m 不互质时，因为 m 为质数，所以 b 为 m 的倍数，即b%m==0 时无解，费马小定理不成立。</p><p>​    当模数 <strong>m 为质数</strong>时且 <strong>b 和 m 互质</strong>时，$b^{m−2}$ 即为 b 的乘法逆元。</p><p>证明：由费马小定理 $ b^{m-1}\equiv 1\%\ m$</p><p>令    $\frac{a}{b}\equiv a\times x \%\ m$</p><p>所以$ \frac{a}{b}\times b^{m-1}\equiv a\times x \% \ m$ </p><p><strong>因此：</strong>$ a \times b^{m-2}\equiv a\times x \% \ m$   a 与 m 互质，约去</p><p><strong>所以：</strong>$x\equiv b^{m-2}  \%m$</p></blockquote><h5 id="5-2-扩展欧几里得求逆元"><a href="#5-2-扩展欧几里得求逆元" class="headerlink" title="5.2 扩展欧几里得求逆元"></a>5.2 扩展欧几里得求逆元</h5><p>扩展欧几里得可以求解<a href="#linear congruent equation">线性同余方程</a> $ax\equiv b\ \ (mod\ \ m)$ </p><p>求模 m 意义中 a 的逆相对于求$ax\equiv1\ \ (mod\ \ m)$， ax-my=1。gcd(a,m) 不为1则说明逆元不存在,若为1，则调整结果为x=(x%mod+mod)%mod.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">exgcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">exgcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">,</span>y<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调换 x y</span>    y<span class="token operator">-=</span>a<span class="token operator">/</span>b<span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">return</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> a<span class="token punctuation">,</span>m<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">exgcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>m<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">%</span>m<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">else</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"No"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-中国剩余定理"><a href="#6-中国剩余定理" class="headerlink" title="6 中国剩余定理"></a>6 中国剩余定理</h3><p>问题：整数 $m_1,m_2,···,m_n$ 两两互素，则对于任意整数$a_1,a_2,···,a_n$，方程组：</p><script type="math/tex; mode=display">\left\{\begin{matrix}  x\equiv a_1\ \ (mod\ \ m_1) \\  x\equiv a_2\ \ (mod\ \ m_2) \\ ······ \\  x\equiv a_n\ \ (mod\ \ m_n)\end{matrix}\right.\\令\ \ M = \prod_{i=1}^{n}m_i  \\则 x\equiv \sum_{i=1}^{n}a_i×\frac{M}{m_i}×[(\frac{M}{m_i})^{-1}]\ \  (mod\ \ M)</script><blockquote><p><a href="https://www.acwing.com/problem/content/206/">扩展中国剩余定理</a></p><script type="math/tex; mode=display">\begin{flalign*}&选取两个方程\ \  x~~ mod~~a_1 = m_1，x\ \ mod\ \  a_2 = m_2\\&可以写成\qquad \ x\ =\ k_1a_1 + m_1，x\ =\ k_2a_2 + m_2\\&由两式得\qquad\ k_1a_1 - k_2a_2 = m_2 - m_1\\&通过扩欧可以知道\  k_1,k_2\ 有解等价于\ gcd(a_1,-a_2)|(m_2-m_1) \\& 解出通解\ \  k_1=k_1+k\frac{a_2}{d},\ k_2=k_2+k\frac{a_1}{d},\ r为任意正整数 \\& 将\ k_1,k_2\ 的通解代回得\ x=(k_1+k\frac{a_2}{d})a_1+m_1=k\frac{a_1a_2}{d}+(k_1a_1+m_1)  \\& 两个方程合并成一个方程，然依次合并到只剩一个，这个式子的解就是答案  \\&注： \frac{a_1a_2}{d}就是\ a_1,a_2\ 的最小公倍数；注意取模。&\end{flalign*}</script></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">ll a1<span class="token punctuation">,</span>m1<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>a1<span class="token operator">&gt;&gt;</span>m1<span class="token punctuation">;</span> <span class="token comment">// 第一个方程</span><span class="token keyword">int</span> f<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">--</span>n<span class="token punctuation">)</span>  <span class="token comment">// 输入第2~n个方程</span><span class="token punctuation">{</span>    ll a2<span class="token punctuation">,</span>m2<span class="token punctuation">,</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>a2<span class="token operator">&gt;&gt;</span>m2<span class="token punctuation">;</span>    ll d<span class="token operator">=</span><span class="token function">exgcd</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span>a2<span class="token punctuation">,</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m2 <span class="token operator">-</span> m1<span class="token punctuation">)</span> <span class="token operator">%</span> d<span class="token punctuation">)</span>  <span class="token comment">// 不是 d 的倍数无解</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// a1k1+a2k2=d的通解为 k1=k1+k*(a2/d)，k=0， k1是正解中最小的</span>    <span class="token comment">// a1k1+a2k2=m2-m1 的通解为, 所以k1要扩大 (m2-m1)/d 倍</span>    k1<span class="token operator">=</span>k1 <span class="token operator">*</span> <span class="token punctuation">(</span>m2 <span class="token operator">-</span> m1<span class="token punctuation">)</span> <span class="token operator">/</span> d<span class="token punctuation">;</span>     <span class="token comment">// 但是经过乘了个 m2-m1 可能变负了</span>    ll t<span class="token operator">=</span>a2<span class="token operator">/</span>d<span class="token punctuation">;</span>   <span class="token comment">// 由通解可知模 t 也是解</span>    k1<span class="token operator">=</span><span class="token punctuation">(</span>k1 <span class="token operator">%</span> t <span class="token operator">+</span> t<span class="token punctuation">)</span> <span class="token operator">%</span> t<span class="token punctuation">;</span>             <span class="token comment">// 新的方程 x = k(a2·a1/d)+k1a1+m1</span>    m1<span class="token operator">=</span>k1 <span class="token operator">*</span> a1 <span class="token operator">+</span> m1<span class="token punctuation">;</span>    a1<span class="token operator">=</span><span class="token function">abs</span><span class="token punctuation">(</span>a1 <span class="token operator">/</span> d <span class="token operator">*</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 最后一个方程是 x=m1 (mod a1), x%a1=m1, m1&lt;a1, 所以m1是一个解</span>cout<span class="token operator">&lt;&lt;</span>m1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-高斯消元"><a href="#7-高斯消元" class="headerlink" title="7 高斯消元"></a>7 高斯消元</h3><h4 id="7-1-线性方程组"><a href="#7-1-线性方程组" class="headerlink" title="7.1 线性方程组"></a>7.1 线性方程组</h4><p>用于求解线性方程组  $ \left\{\begin{matrix}<br>a_{11}x_1+a_{12}x_2+···+a_{1n}x_n=b_1 \\<br>a_{21}x_1+a_{22}x_2+···+a_{2n}x_n=b_2 \\<br>······ \\<br>a_{n1}x_1+a_{n2}x_2+···+a_{nn}x_n=b_n<br>\end{matrix}\right.$ </p><p>矩阵形式为 $Ax=B$，$A=\begin{bmatrix}<br> a_{11} &amp; a_{12} &amp; ··· &amp; a_{1n}\\<br> a_{11} &amp; a_{12} &amp; ··· &amp; a_{1n} \\<br> ··· &amp; ··· &amp; ··· &amp; ···\\<br> a_{11} &amp; a_{12} &amp; ··· &amp; a_{1n}<br>\end{bmatrix}$，$B=\begin{bmatrix}<br> b_1\\<br>b_2\\<br>\vdots  \\<br>b_n<br>\end{bmatrix}$ 。</p><p>将增广矩阵 [AB] 初等变换为化为上三角。高斯消元就是这个过程。</p><blockquote><ol><li>选取系数最大的那行，可以避免系数变得太大，精度较高，将r行与下面的行比较，不与第一行比</li><li>若最大的是 0，此行全 0，则无需操作</li><li>将含有更大的数这行与 r 行交换</li><li>将 r 行同时除 a[r,c],使a[r,c]=1</li><li>用新的 r 行对下面所有行的第c列消为 0，消的元素对应的每一个元素都要改变，此时 a[r,c]=1,所以j行-r行×a[i,c]即可</li><li>r++，接着操作下一行，重复上述过程。</li><li>根据R(A),R(AB),n的关系判断解的情况</li></ol></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> a<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">,</span>r<span class="token punctuation">;</span>  <span class="token comment">// r 是行，计算后也代表矩阵的秩</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>c<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>c<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 枚举每一列</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>r<span class="token punctuation">;</span>        <span class="token comment">// 1、最大系数可以避免系数变得太大，精度较高</span>        <span class="token comment">//    将r行与下面的行比较，不与第一行比</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                t<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token comment">// 2、最大的是 0，此行全 0</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>eps<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 3、将含有更大的数这行与 r 行交换</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>c<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4、将 r 行同时除 a[r][c],使a[r][c]=1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&gt;=</span>c<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>  a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 5、用这行对下面行的第c列消为 0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>eps<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment">// 消0对应的行的每一个元素都要改变</span>                <span class="token comment">// 此时 a[r][c]=1,所以j行-r行×a[i][c]即可</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>n<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>c<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>                    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-=</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token comment">// 6、接着对第 r+1 行操作</span>        r<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 7、判断解的情况</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">&gt;</span>eps<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// R(A)&lt;R(AB)，无解</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// R(A)=R(AB)&lt;n 无穷解</span>    <span class="token punctuation">}</span>    <span class="token comment">// R(A)=R(AB)=n 唯一解</span>    <span class="token comment">// 已经化成上三角形式,从右下角开始化成除增广B矩阵外仅正对角线形式</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>c<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>c<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">// 从左往右枚举列</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>r<span class="token operator">&lt;</span>c<span class="token punctuation">;</span>r<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 行</span>            a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">-=</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">*</span>a<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// c 也代表选中的1在的列</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-异或方程组"><a href="#7-2-异或方程组" class="headerlink" title="7.2 异或方程组"></a>7.2 异或方程组</h4><p>异或可以看出不进位的加法，同样可通过系数矩阵求解，即初等变换不改变解</p><p>异或方程组 $ \left\{\begin{matrix}<br>a_{11}x_1 \oplus a_{12}x_2\oplus···\oplus a_{1n}x_n=b_1 \\<br>a_{21}x_1\oplus a_{22}x_2\oplus ···\oplus a_{2n}x_n=b_2 \\<br>······ \\<br>a_{n1}x_1\oplus a_{n2}x_2\oplus ···\oplus a_{nn}x_n=b_n<br>\end{matrix}\right.$，$a_{ij}，b_{ij}=0\ \  or\ \ 1$ </p><p>对矩阵增广矩阵 [AB] 操作目标和线性方程组相同，代码这样写的原因也和普通高斯消元类似。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">gauss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>c<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>c<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> t<span class="token operator">=</span>r<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                t<span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 这一列全为 0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>c<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 因为a[r][c]=1，省略化为 1 的过程</span>        <span class="token comment">// 对 r 行以下的行的 c 列消0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>c<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 都是1，直接两行对应位置异或</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">^=</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        r<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>c<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>c<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>r<span class="token operator">&lt;</span>c<span class="token punctuation">;</span>r<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">^=</span>a<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-组合数"><a href="#8-组合数" class="headerlink" title="8 组合数"></a>8 组合数</h3><blockquote><p>组合数公式：</p><ol><li><p>$C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$ 用于递推、预处理</p></li><li><p>$C_a^b=C_{a}^{a-b}=\frac{a!}{b!(a-b)!}$ 用于直接求，需要求逆元</p></li><li><p>$ C_n^0+C_n^1+C_n^2+···+C_n^n=2^n $</p><p>证明：想一下，从 n 个物品取，求取法，左边是从0个，1个···到n个的取法，它们的和就是总取法，右边可以表示一个商品有两种状态，取或者不取，由乘法原理可知是$2^n$。</p><p>严谨的数学归纳法：n=1,显然成立。</p><p>假设 n=k 时公式成立 $\sum_{i=0}^{k}C_k^i=2^n$，那么当 n=k+1 时</p><p>$ C_{k+1}^{0}+C_{k+1}^{1}+···+C_{k+1}^{k}+C_{k+1}^{k+1} = 2 $，由公式 1. 可以将$C_{k+1}^{i}$ 拆成两部分，发现正好等于 2倍的 $\sum_{i=0}^{k}C_k^i$，即 2*2^k^=2^k+1^。</p></li><li><p>==二项式系数==：$(a+b)^n=C_{n}^{0}b^n+C_{n}^{1}ab^{n-1}+···+C_{n}^{i}a^ib^{n-i}+···+C_{n}^{n}a^n $ </p><p>证明：数学归纳···</p></li><li><p>==卢卡斯定理==：$C_a^b\equiv C_{a\%p}^{b\%p}·C_{a/p}^{b/p}\ \ (mod\ \ p)$ 用于求a、b较大的情况</p><p>另一种形式$C_a^b=C_{a_0}^{b_0}+C_{a_1}^{b_1}+···+C_{a_k}^{b_k}\ \ \ (mod\ \ p)$，其中</p><p>$a=a_0+a_1p+a_2p^2+···+a_kp^k$，$b=b_0+b_1p+b_2p^2+···+b_kp^k$ </p></li></ol><p>证明：</p><p>首先证明   $(1+x)^p \equiv 1+x^p\ \ (mod\ \ p)$ </p><p>$左边=C_p^01+C_p^1x+C_p^2x^2+···+C_p^px^p$，因为$C_p^i=\frac{p!}{(p-i)!·i!}$，p为质数，所以当 $0&lt;i&lt;p$ 时，$C_p^ix^i$ 被 p 取模消去，所以只留下两端，得证。</p><p>同理证得: $(1+x)^{p^\alpha}\equiv 1+x^{p^\alpha } \ \ (mod\ \ p)$ .</p><p>将 $a，b$ 转化为 p 进制数，$a=a_0+a_1p+a_2p^2+···+a_kp^k$，$b=b_0+b_1p+b_2p^2+···+b_kp^k$ </p><script type="math/tex; mode=display">\begin{align*}(1+x)^a &= (1+x)^{a_0+a_1p+a_2p^2+···+a_kp^k}\\& = (1+x)^{a_0}\times((1+x)^{p_1})^{a_1}\times···\times((1+x)^{p_k})^{a_k}\\&\equiv(1+x)^{a_0}\times(1+x^{p^1})^{a_1}\times···\times(1+x^{p^k})^{a_k}\ \ (mod\ \ n) &\end{align*}</script><p>$C_a^b$ 就是 $(1+x)^a$ 展开式中 $x^b$ 的系数，即 $x^{b_0+b_1p+b_2p^2+···+b_kp^k}$ 的系数。对比左边和右边每一项 $x^b$ 的系数可知</p><p>$C_a^b\equiv C_{a_0}^{b_0}\times C_{a_1}^{b_1}\times ···\times C_{a_k}^{b_k}\ \ (mod\ \ n) $ </p><p>$C_{a_0}^{b_0}=C_{a\%p}^{b\%p}$，因为转化为p进制的第一位就是对 p 取余得到的</p><p>$C_{a/p}^{b/p}=C_{a_1}^{b_1}\times ···\times C_{a_k}^{b_k}$，p 进制下，将 a，b 右移一位相当于 /p ，和 $C_a^b$ 一样分析，证明这个式子是正确。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> init<span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// i 代表总的，j 代表 被选的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">)</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>  c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">%</span>mod<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m<span class="token operator">=</span>jc<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span>z<span class="token operator">=</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>jc<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">*</span>jc<span class="token punctuation">[</span>a<span class="token operator">-</span>b<span class="token punctuation">]</span><span class="token operator">%</span>mod<span class="token punctuation">;</span><span class="token comment">// 预处理的阶乘数组</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>m<span class="token operator">*</span><span class="token function">kpow</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span>mod<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>  <span class="token comment">// 快速幂求逆元</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lucas</span><span class="token punctuation">(</span>ll a<span class="token punctuation">,</span>ll b<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span>p <span class="token operator">&amp;&amp;</span> b<span class="token operator">&lt;</span>p<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">c</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span><span class="token function">c</span><span class="token punctuation">(</span>a<span class="token operator">%</span>p<span class="token punctuation">,</span> b<span class="token operator">%</span>p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">lucas</span><span class="token punctuation">(</span>a<span class="token operator">/</span>p<span class="token punctuation">,</span> b<span class="token operator">/</span>p<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不取模的组合数，高精度+质因子分解</p><p>将阶乘分式约分，消去分母，再将分母质因子分解，答案就是这些质因子的乘积。</p><p>求 n！质因子个数: $num = \frac{n}{p}+\frac{n}{p}+···+\frac{n}{p^k}$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 求质因子及其个数的过程 </span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment">// num=n/p+n/p^2+···</span>    <span class="token punctuation">{</span>        res<span class="token operator">+=</span>n<span class="token operator">/</span>p<span class="token punctuation">;</span>        n<span class="token operator">/=</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// C(a,b)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> p<span class="token operator">=</span>primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">get</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">get</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 统计个数</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-博弈论"><a href="#9-博弈论" class="headerlink" title="9 博弈论"></a>9 博弈论</h3><p>若一个游戏满足：</p><ol><li>由两名玩家交替行动</li><li>游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关</li><li>不能行动的玩家判负</li><li>则称该游戏为一个公平组合游戏</li></ol><p>==必胜状态==：先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。可以走到某一个必败状态。</p><p>==必败状态==：先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。走不到任何一个必败状态。</p><h5 id="9-1-Nim游戏"><a href="#9-1-Nim游戏" class="headerlink" title="9.1 Nim游戏"></a>9.1 Nim游戏</h5><p>给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><blockquote><p>结论：有 n 堆石子，石子数目分别是 $a_1,a_2,…,a_n$ 如果$a_1⊕a_2⊕…⊕a_n=x≠0$，先手必胜；否则先手必败。</p><p>（1）在操作过程中，如果 $a_1⊕a_2⊕…⊕a_n=x≠0$。那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为0。</p><p>证明：设 x 的二进制表示中最高的一位 1 在第 k ，那么 $a_1 \sim a_n$ 必然存在一个数 $a_i$ 的第 k 位是 1，且 $a_i\oplus x&lt;a_i$，然后从第 i 堆石子拿出 $a_i-a_i\oplus x$，第 i 堆还剩 $a_i\oplus x$ 个,这时有：$a_1⊕a_2⊕…\oplus a_i\oplus x\oplus…⊕a_n= 0$ </p><p>（2）在操作中，若 $a_1⊕a_2⊕…⊕a_n=0$，那么无论玩家怎么取，最终异或和都不为0。</p><p>证明（反证法）：假设玩家从第 $i$ 堆石子拿走若干个，异或和结果仍是 0。设剩下的石子为 $a’$，所以必然有 $0\le a’&lt;a_i$，且 $a_1⊕a_2⊕……⊕a’⊕…⊕a_n=0$，所以联立原式和取后的式子，$(a_1⊕a_2⊕…⊕a_i⊕…a_n)⊕(a_1⊕a_2⊕…⊕a′⊕…⊕a_n)=a_i⊕a′=0$，这个式子说明 $a_i=a’$，与假设矛盾，因此得证。</p><p>由(1)，(2)可知：</p><ol><li><p>如果先手面对的局面是 $a_1⊕a_2⊕…⊕a_n≠0$，那么先手总可以通过拿走某一堆若干个石子，将局面变成 $a_1⊕a_2⊕…⊕a_n=0$。如此重复，最后一定是后手面临最终没有石子可拿的状态。先手必胜。</p></li><li><p>如果先手面对的局面是 $a_1⊕a_2⊕…⊕a_n=0，那么无论先手怎么拿，都会将局面变成 $$a_1⊕a_2⊕…⊕a_n≠0$，那么后手总可以通过拿走某一堆若干个石子，将局面变成 $a1⊕a2⊕…⊕an=0$。如此重复，最后一定是先手面临最终没有石子可拿的状态。先手必败。</p></li></ol></blockquote><p>==台阶-Nim游戏==：现在，有一个 n 级台阶的楼梯，每级台阶上都有若干个石子，其中第 i 级台阶上有 $a_i$ 个石子(i≥1)。两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。</p><p>问如果两人都采用最优策略，先手是否必胜?</p><blockquote><p>结论：<strong>奇数楼梯</strong>石子数异或和为 不为 0，先手必胜，否则先手必败</p><p>证明：游戏的终点是所有楼梯上的石子全为 0。</p><p>（1）在操作过程中，初始 $a_1\oplus a_3\oplus…=x\ne0$ ，那么最佳策略是从某奇数楼梯若干个取石子，可使奇数楼梯异或和为 0。</p><p>证明：设 x 的二进制表示中最高的一位 1 在第 k ，那么 $a_1 、a_3、a_5…$ 必然存在一个数 $a_i$ 的第 k 位是 1，且 $a_i\oplus x&lt;a_i$，然后从第 i 堆石子拿出 $a_i-a_i\oplus x$，第 i 堆还剩 $a_i\oplus x$ 个,这时有：$a_1⊕a_3⊕…\oplus a_i\oplus x\oplus…= 0$ 。</p><p>（2）在操作中，若 $a_1⊕a_3⊕a_5\oplus……=0$，那么无论玩家怎么取，最终异或和都不为0。</p><p>证明：</p><ul><li>从偶数拿下去，偶数必不可能直接拿到地面。不妨设拿了 x 个石子到下一阶奇数楼梯，那么 $a_1⊕a_3⊕a_5\oplus…\oplus x=0\oplus x=x\ne0$，所以这种情况不为0。</li><li>从奇数楼梯拿下去。（反证法）：假设玩家从奇数第 $i$ 堆石子往下拿若干个，异或和结果仍是 0。设剩下的石子为 $a’$，所以必然有 $0\le a’&lt;a_i$，且 $a_1⊕a_2⊕……⊕a’⊕…=0$，所以联立原式和取后的式子，$(a_1⊕a_2⊕…⊕a_i⊕…a_n)⊕(a_1⊕a_2⊕…⊕a′⊕…⊕a_n)=a_i⊕a′=0$，这个式子说明 $a_i=a’$，与假设矛盾，因此得证。</li><li>由上述两个证明可知，当 $a_1⊕a_3⊕a_5\oplus……=0$ 时，先手无论怎么 拿，后手都能使下一次先手遇到未奇数异或和为0。而游戏结束时奇数异或和是0，所以先手先遇到无法操作的情况。而 $a_1⊕a_3⊕a_5\oplus……\ne 0$ 时，先手可以选择拿走奇数堆若干个使奇数堆偶数和为0，让后手先遇到无法操作的情况。得证。</li></ul></blockquote><h5 id="9-2-SG-函数"><a href="#9-2-SG-函数" class="headerlink" title="9.2 SG 函数"></a>9.2 SG 函数</h5><p>==Mex运算==：设S表示一个非负整数集合.定义 mex(S) 为求出不属于集合S的最小非负整数运算, 即: mes(S)=min{x}。</p><p>​    例如:S={0,1,2,4}, 那么 mex(S)=3</p><p>==有向图游戏==：给定一个有向无环图，图中有一个<strong>唯一的起点</strong>，在起点上放有一枚棋子。两名玩家<strong>交替</strong>地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。</p><p>==公平组合游戏==：</p><p>（1）有两个玩家，游戏规则对两个玩家公平</p><p>（2）游戏状态有限，能走的步数也是有限的</p><p>（3）轮流走，当一个玩家不能走时游戏结束</p><p>（4）游戏的局势不能区分玩家的身份，例如黑白棋就是不行的</p><p>（5）给定初始局势，指定先手玩家，如果双方都采取最优策略，那么<strong>获胜者已经确定</strong>了，也就是说ICG问题存在必胜策略</p><p>​    任何一个<strong>公平组合游戏</strong>都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><p>==SG函数==：在有向图游戏中,对于每个节点 $x$，设从 $x$ 出发共有 $k$ 条有向边,分别到达节点 $y_1,y_2,····y_k$，定义 $SG(x)$ 的后记节点 $y_1,y_2,····<br>y_k$ 的SG函数值构成的集合在执行 <strong>mex运算</strong> 的结果,即:<br>$SG(x)=mex(\{SG(y_1),SG(y_2)····SG(y_k)\})$<br>特别地,整个有向图游戏 G 的SG函数值被定义为有向图游戏起点 s 的SG函数值,即 SG(G)=SG(s).</p><p>==有向图游戏和==：设 $G_1，G_2,····,G_m$ 是 m 个有向图游戏.定义有向图游戏G,他的行动规则是任选某个有向图游戏 $ G_i$，并在 $G_i$ 上行动一步.G被称为有向图游戏 $G_1,G_2,·····,G_m$ 的和.<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和,即:<br>$SG(G)=SG(G_1)\oplus SG(G_2)\oplus···\oplus SG(G_m)$ 。</p><p>若 SG(G)=0，则先手必败，否则先手必胜，证明同Nim游戏 </p><p>求SG函数异或和，一般用记忆化搜索的方式：</p><p><a href="https://www.acwing.com/problem/content/description/895/">集合-Nim游戏</a>：看成多个有向图，一个数可以变为其他，返回递归求的这个数的SG值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> se<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&gt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  se<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">sg</span><span class="token punctuation">(</span>x<span class="token operator">-</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>se<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/description/896/">拆分-Nim游戏</a>：一堆分成多堆，一个图变成两个图，那么SG(G)=SG(G~1~)^SG(G~2~)。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&gt;</span> se<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>x<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            se<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">sg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">^</span><span class="token function">sg</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将两个图的SG异或起来就得到了</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>se<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-容斥原理"><a href="#10-容斥原理" class="headerlink" title="10 容斥原理"></a>10 容斥原理</h3><p>图图</p><p>证明：假设元素 x 在 k 个集合中出现，则被计算的次数为</p><p>$C_k^1 - C_k^2+C_k^3+···+(-1)^{k-1}C_k^k $ ，由二次项展开可知，该式等于 $-(1-1)^k+1=C_k^0=1 $，因此一个元素只被计算一次。</p><p>常常与二进制枚举配合使用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 1~1111, 共有 2^n-1种选法</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 数组从 0 开始</span>    <span class="token punctuation">{</span>        <span class="token comment">// i&gt;&gt;j &amp; 1</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 判断i低j位是否为1，若为1 则选择这个</span>        <span class="token punctuation">{</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 选择个数+1，</span>            <span class="token comment">// 对这个数进行某种操作</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 对选择的进行计算，比如奇数个 加，偶数个 减。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-卡特兰数"><a href="#11-卡特兰数" class="headerlink" title="11 卡特兰数"></a>11 卡特兰数</h3><p><strong>卡特兰数</strong>：$C_{2n}^n - C_{2n}^{n-1}=\frac{C_{2n}^n}{n+1}$  </p><p>应用：<a href="https://www.acwing.com/problem/content/891/">构造01序列</a>，<a href="https://www.acwing.com/problem/content/132/">火车进出栈</a>，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> res<span class="token operator">=</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>res<span class="token operator">*</span>i<span class="token operator">%</span>mod<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">exgcd</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>mod<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    x<span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">%</span>mod<span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>    res<span class="token operator">=</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>res<span class="token operator">*</span>x<span class="token operator">%</span>mod<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h2><h3 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1 背包问题"></a>1 背包问题</h3><h4 id="1-1-01背包"><a href="#1-1-01背包" class="headerlink" title="1.1 01背包"></a>1.1 01背包</h4><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能<strong>使用一次</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，</p><p>且总价值最大。输出最大价值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 二维形式</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 一维优化</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-完全背包"><a href="#1-2-完全背包" class="headerlink" title="1.2 完全背包"></a>1.2 完全背包</h4><p>有 $N$ 种物品和一个容量是 $V$ 的背包，每种物品都有<strong>无限件可用</strong>。第 $i$ 种物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">\\三重循环：<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>j <span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    f<span class="token punctuation">[</span>i，j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\<span class="token operator">*</span> 优化至二重循环f<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>v<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>w<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">3</span><span class="token operator">*</span>v<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">3</span><span class="token operator">*</span>w<span class="token punctuation">,</span>……<span class="token punctuation">)</span>f<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>       f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>  f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">,</span>  f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">3</span><span class="token operator">*</span>v<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>w<span class="token punctuation">,</span>……<span class="token punctuation">)</span>由上两式，可得出如下递推关系： f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span>该递推式和<span class="token number">01</span>背包递推式只有 f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span> 不一样完全背包用的是当前循环的值，所以从小到大循环<span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 优化至一维</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完全背包变形</strong>：<a href="https://www.acwing.com/problem/content/902/">整数划分</a></p><p>一个正整数 $n$ 可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k$，其中 $n_1≥n_2≥…≥n_k,k≥1$。我们将这样的一种表示称为正整数 $n$ 的一种划分。现在给定一个正整数 $n$，请你求出 $n$ 共有多少种不同的划分方法。</p><p>将 a[]= {1，2，3，···，n} 看成 n 种物品，每种物品可以用无限次，体积为 $a_i$。</p><p>f[i,j] 代表选择前 i 个和为 j 的方案数。</p><p>任何一种选法都代表着一种划分。</p><p>那么递推式推导和完全背包递推式推导一样</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 选 i = 不选 i 且体积为 j-k*i 的情况之和</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">+</span>···<span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token operator">*</span>s<span class="token punctuation">]</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">=</span>        f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token operator">+</span>···<span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token operator">*</span>s<span class="token punctuation">]</span>所以 f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token comment">// 所以二维做法是</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>i<span class="token punctuation">)</span>  f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Amezing!</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span>    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> i<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-多重背包"><a href="#1-3-多重背包" class="headerlink" title="1.3 多重背包"></a>1.3 多重背包</h4><p>有 $N$ 种物品和一个容量是 $V$ 的背包。</p><p>第 $i$ 种物品<strong>最多有 $s_i$ 件</strong>，每件体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">\\ 朴素多重背包，循环 s 次这个物品 <span class="token function">O</span><span class="token punctuation">(</span>NVS<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二进制优化它选某种物品的方法 O(NVlogS)<br>将物品拆分成 1，2，4，8，……，然后进行01背包</p><blockquote><p>在多重背包转化01背包中，将 s 件物品分成 1，2，4，……，2^k，sum 是正确的</p><p>证明：s 可以表示成二进制形式，枚举二进制形式的 1 ，有两种选择方式，选或者不选，通过这两种状态，物品选择范围可以到 0~s 。</p><p>例如 s=9=1001，被拆分为 1，10，100，即 1 2 4 9-7=2。通过这些物品的组合可以凑出选择 s 的所有情况。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>V<span class="token operator">/</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能选择 i 的最大数量</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>num<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 划分为 1 2 4 ···</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">&gt;</span>num<span class="token punctuation">)</span> k<span class="token operator">=</span>num<span class="token punctuation">;</span>  <span class="token comment">// 2^n要大于剩余的</span>        num<span class="token operator">-=</span>k<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token operator">*</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-分组背包"><a href="#1-4-分组背包" class="headerlink" title="1.4 分组背包"></a>1.4 分组背包</h4><p>有 $N$ 组物品和一个容量是 $V$ 的背包。</p><p>每组物品有 $s_i$ 种，<strong>同一组内的物品最多只能选一个</strong>。每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>枚举组，从组中选一个就行。01背包倒序枚举V，每次使用的都是上组的f，因此保证了每组只选了一个，且这一个整体来看是最划算的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-线性DP"><a href="#2-线性DP" class="headerlink" title="2 线性DP"></a>2 线性DP</h3><h4 id="2-1-最长上升子序列"><a href="#2-1-最长上升子序列" class="headerlink" title="2.1 最长上升子序列"></a>2.1 最长上升子序列</h4><p>给定一个长度为 $N$ 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 朴素做法</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单调栈优化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 栈是递增的</span>stk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span>inf<span class="token punctuation">;</span> <span class="token comment">// 栈底置为无穷小</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">// 直接加后面</span>    stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>   <span class="token comment">// 找一个大于等于 a[i] 的替换掉，栈仍然单调</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>stk<span class="token punctuation">,</span>stk<span class="token operator">+</span>tt<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>stk<span class="token punctuation">;</span>        stk<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// tt 即为最大长度，stk 为选的数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-最长公共子序列"><a href="#2-2-最长公共子序列" class="headerlink" title="2.2 最长公共子序列"></a>2.2 最长公共子序列</h4><p>给定两个长度分别为 $N$ 和 $M$ 的字符串 $A$ 和 $B$，求既是 $A$ 的子序列又是 $B$ 的子序列的字符串长度最长是多少。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                 f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-编辑距离"><a href="#3-编辑距离" class="headerlink" title="3 编辑距离"></a>3 编辑距离</h3><p>一下操作将字符串 A 变为距离为 1 的其他字符串</p><ol><li><strong>删除</strong>–将字符串 A 中的某个字符删除。</li><li><strong>插入</strong>–在字符串 A 的某个位置插入某个字符。</li><li><strong>替换</strong>–将字符串 A 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 A 变为 B 至少需要进行多少次操作。</p><p>A → B 的方式：删，增，改，不变</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">// f(i,j) 表示 a 前 i，变成 b 前 j 的距离int f[N][N];  for(int i=1;i&lt;=n;i++) f[i][0]=i;for(int i=1;i&lt;=m;i++) f[0][i]=i;for(int i=1;i&lt;=n;i++){    for(int j=1;j&lt;=m;j++)    {        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);        if(a[i]!=b[j])            f[i][j]=min(f[i][j],f[i-1][j-1]+1);        else f[i][j]=f[i-1][j-1];    }}cout&lt;&lt;f[n][m]&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-区间DP"><a href="#4-区间DP" class="headerlink" title="4 区间DP"></a>4 区间DP</h3><p><a href="https://www.acwing.com/problem/content/284/">合并石子</a> </p><p>先枚举区间长度，在枚举可行的左端点，对应算出右端点，然后枚举中间点，状态整合。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>len<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>len<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token comment">// 枚举区间的长度</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 左端点</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 右端点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token punctuation">;</span>k<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>sum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-数位DP"><a href="#5-数位DP" class="headerlink" title="5 数位DP"></a>5 数位DP</h3><h3 id="6-状态压缩DP"><a href="#6-状态压缩DP" class="headerlink" title="6 状态压缩DP"></a>6 状态压缩DP</h3><p><a href="https://www.acwing.com/problem/content/293/">蒙德里安的梦想</a> </p><p>当放完横向的方格时，竖向的小方格放置情况就唯一且确定了，所以问题转化为只放横向的小方格的方案数量。</p><p>f(i,j) 表示前 i-1 列已摆好，且从 i-1 列伸出到的第 i 列的状态是 j 的所有方案数。</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E7%8A%B6%E5%8E%8BDP" alt="img"></p><p><a href="https://www.acwing.com/problem/content/93/">路径最短Hamilton</a> </p><p>用二进制数表示走了哪几个点。</p><p>f(i,j)表示所有从 0 走到 j 的，路过点的情况是 i 的所有路径的花费最小值。</p><p>例如：i=0100110 表示经过了 点1、4、5，没经过0、2、3、6。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 到起点的花费为 0 </span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历所有路径情况</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;&gt;</span>j<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//  j 点在路径 i 中</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 从 k 点转移到 j</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;&gt;</span>k<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 需确保 k 在路径 i 中</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ans<span class="token operator">=</span>f<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 经过所有点，到达 n-1 点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-树形DP"><a href="#7-树形DP" class="headerlink" title="7 树形DP"></a>7 树形DP</h3><p>在一颗树上进行动态规划。</p><p><a href="https://www.acwing.com/problem/content/287/">没有直接上司的舞会</a> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment">// 表示选了 x 点</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment">// 表示没选 x 点</span><span class="token keyword">void</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 不放在下面加是因为叶子结点不会进入下面的循环</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dp</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+=</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-记忆化搜索"><a href="#8-记忆化搜索" class="headerlink" title="8 记忆化搜索"></a>8 记忆化搜索</h3><p>记下dfs的返回值</p><p><a href="https://www.acwing.com/problem/content/description/903/">滑雪</a> </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    st<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ma<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token operator">=</span>x<span class="token operator">+</span>dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token operator">=</span>y<span class="token operator">+</span>dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>a<span class="token operator">&lt;=</span>r<span class="token operator">&amp;&amp;</span>b<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>b<span class="token operator">&lt;=</span>c<span class="token operator">&amp;&amp;</span>mp<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">&lt;</span>mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            s<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            ma<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>ma<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第六章-贪心"><a href="#第六章-贪心" class="headerlink" title="第六章 贪心"></a>第六章 贪心</h2><p><a href="https://www.acwing.com/problem/content/908/">区间分组</a></p><p><a href="https://www.acwing.com/problem/content/127/">耍杂技的牛</a></p><p>题解：拿出相邻的两头牛上面的编号为 i，下面的编号为 i+1。</p><p>两头牛的体重和强壮度有什么关系，i 在上能使 i 头牛和 i+1 头牛的风险度最大值最小。</p><p>当前情况：</p><p>第 i 头牛的风险为：$R_i=\sum_{j=1}^{i-1}W_j-S_i$</p><p>第 i+1 头牛的风险为：$ R_{i+1}=\sum_{j=1}^{i-1}W_j+W_i-S_{i+1}$ </p><p>交换 i 与 i+1，风险度变为：</p><p>第 i 头牛的风险为：$R_i=\sum_{j=1}^{i-1}W_j+W_{i+1}-S_i$ </p><p>第 i+1 头牛的风险为：$ R_{i+1}=\sum_{j=1}^{i-1}W_j-S_{i+1}$ </p><p>去掉相同部分，若交换前风险度最大值是最小的需要保证 $MAX(-S_i,W_i-S_{i+1})\le MAX(W_{i+1}-S_i,-S_{i+1})$。</p><p>显然 $-S_i\le W_{i+1}\ 和\ W_i-S_{i+1}&gt;-S_{i+1}$，因此只需保证 $W_i-S_{i+1}\le W_{i+1}-S_i$，移项得$ W_i+S_i\le W_{i+1}+S_{i+1}$。</p><p>所以该题目按照 W+S 排序即可。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-提高</title>
      <link href="/suan-fa/suan-fa-bi-ji-ti-gao/"/>
      <url>/suan-fa/suan-fa-bi-ji-ti-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章 动态规划"></a>第一章 动态规划</h2><h3 id="1-数字三角形"><a href="#1-数字三角形" class="headerlink" title="1 数字三角形"></a>1 数字三角形</h3><p>在矩阵里走路，从左上角走到右下角问题</p><p><a href="https://www.acwing.com/problem/content/277/">传纸条</a></p><p>关键在于分析矛盾情况，这个点是否可以走，可以由哪里来。根据状态计算来到当前点的值。</p><p>通常设置 f(k,i,u) 为集合，k 为总共走了多少步，i 为第一个点的横坐标，u 为第二个点的横坐标。由于两个点走的步数相同，因此当 i==u 时，二者相遇到同一点。</p><h3 id="2-最长上升子序列模型"><a href="#2-最长上升子序列模型" class="headerlink" title="2 最长上升子序列模型"></a>2 最长上升子序列模型</h3><p>基础版</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// memset 只能初始化为 0 -1 0x3f</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>各种变形</p><p>1 <strong>上升下降</strong>最长子序列：<a href="https://www.acwing.com/problem/content/1016/">登山 </a> </p><p>先从左往右求以 i 为结尾的最长上升子序列 f，再从右往左求以 i 为结尾的最长上升子序列 g，则答案为 max(f(i)+g(i)-1)。</p><p>2 <strong>友好城市</strong>建桥不相交问题：<a href="https://www.acwing.com/problem/content/1014/">友好城市</a> </p><p>左边按坐标排序，求右边的最长上升子序列即可。</p><p>3 <a href="https://www.acwing.com/problem/content/1018/">最大上升子序列和</a>  </p><p>这次不是求长度了，是求上升子序列中的最大和。类比长度计算即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memcpy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 a 全赋值给 f</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4 数组中，最少的不上升子序列覆盖数组：<a href="https://www.acwing.com/problem/content/1012/">拦截导弹</a> </p><ul><li><p>第一问求一个拦截系统最多能拦截多少个导弹，求最长不上升子序列即可。</p></li><li><p>第二问求至少需要多少个拦截系统能拦截所有导弹：贪心计算</p><p>维护多个系统末尾高度数组，这个数组是递增的，当新来一个导弹，若导弹大于所有系统的末尾高度，则新开一个系统并将该导弹高度作为新系统末尾高度，否则寻找一个不小于导弹高度中最小的那个与之交换。</p><blockquote><p>==调整法==贪心证明：假设第 i 个数 x ，贪心解和最优解放置方案不一样，</p><p>x 在贪心解中接在 a 后面，在最优解中接在 b 后面，此时 $x\le a\le b$ ，那么必然可以将贪心解 x 后面的序列和最优解 x 后面的序列进行交换，因此在结果不变的情况下贪心解必然可以转换为最优解，因此贪心是正确的。</p></blockquote></li></ul><p>5 最少的上升子序列和下降子序列覆盖：<a href="https://www.acwing.com/problem/content/description/189/">导弹防御</a> </p><p>   可以观察到 $n\le50$ 范围比较小。考虑贪心+剪枝dfs。</p><p>​    </p><p>6 时间复杂度的优化 $O(nlogn)$ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 栈是递增的</span>stk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span>inf<span class="token punctuation">;</span> <span class="token comment">// 栈底置为无穷小</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">// 直接加后面</span>    stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>   <span class="token comment">// 找最小的大于等于 a[i] 的替换掉，栈仍然单调</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>stk<span class="token punctuation">,</span>stk<span class="token operator">+</span>tt<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>stk<span class="token punctuation">;</span>        stk<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// tt 即为最大长度，stk 为选的数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7 <a href="https://www.acwing.com/problem/content/274/">最长上升公共子序列</a> </p><p>寻找两个数组的最长公共子序列</p><p>f(i,j) 表示 $a(1\sim i)$，$b(1\sim j)$ 中以 $b_j$ 结尾的最长公共上升子序列的长度最大值。</p><ol><li>不包含 $a_i$ ，最大值为 $f[i-1,j]$ </li><li>包含 $a_i$，如果 $a_i\ne b_j$，相当于不包含 $a_i$。所以考虑 $a_i=b_j$， 然后继续划分，子序列是由 $b$ 前面哪个承接过来的。所以要枚举 b 数组前面的每一项，若 $b_k&lt;b_j$，则可以转移过来，所以最大长度是 $f[i,k]+1$。</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> ma<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> ma<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ma<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">,</span>k<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">// 优化：由于是枚举小于 ai 或者说是 bj 的值，而第二层循环就是在已知ai的情况下枚举 b[1~j), 所以可以承担这个功能</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ma<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>  f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>   ma<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ma<span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-背包模型"><a href="#3-背包模型" class="headerlink" title="3 背包模型"></a>3 背包模型</h3><p>1 多个花费问题：<a href="https://www.acwing.com/problem/content/description/1024/">宠物小精灵之收服</a> </p><p>该题有皮卡丘的精灵球和体力两个消耗品，所以 f 变成了二维数组，枚举体积变成枚举两层循环，枚举精灵球和体力。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>n<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>      <span class="token comment">// 枚举精灵球个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span>m<span class="token punctuation">;</span>x<span class="token operator">&gt;=</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>x<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">// 枚举体力</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2 求组合的数量：<a href="https://www.acwing.com/problem/content/description/280/">数字组合</a> </p><p>每个数字只能选一个，可以套用 <strong>01背包</strong>，f[i,j]表示从前 $i$ 个数中选，选中的数的和为 j 的方案数。那么集合属性不再是 max 了，而是求和，所以状态计算中改成求和。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//根据实际意义初始化，从前 0 个选数，和为0的方案是1</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当每个数字可以选多个时，可以套用 <strong>完全背包</strong>。例：<a href="https://www.acwing.com/problem/content/1025/">买书</a>、<a href="https://www.acwing.com/problem/content/1023/">1021货币系统</a> </p><p>这里买书每本可以买多本，问买书的方案有多少种。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>price<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>price<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3 求数组的最大独立集 <a href="https://www.acwing.com/problem/content/534/">532货币系统</a> </p><p>从数组 a 选出最小的集合，条件为：选取集合中的数可以线性表示 数组 a 中的所有数。</p><p>将 a 从小到大排序，$a_i$ 观察能被 $a_{1\sim\ i-1}$ 表示出来</p><p>完全背包问题，将 $a_i$ 视为体积，问使用前 $i-1$ 个物品，$a_j$ 的体积为 $j$，问能否装满 $a_i$ 体积。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>a<span class="token operator">+</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// f[j] 表示前 i-1 个物品能否表示第 i 个 </span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// 这里只使用了前 i-1 个物品</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// 使用第 i 个物品</span>        f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4 单调队列优化的多重背包</p><p><a href="https://www.acwing.com/problem/content/6/">多重背包问题 III</a> </p><p>二进制优化时间复杂度 $O(NMlog(s))$，单调队列的优化 $O(NM)$。</p><p><a href="https://www.acwing.com/solution/content/53507/">题解 </a> </p><p>考虑用完全背包的方式取优化多重背包。将多重背包写成</p><script type="math/tex; mode=display">\begin{align}f(i,j) &=max(\ f(i-1,j)，f(i-1,j-v)+w，··· ，f(i-1,j-sv)+sw\\f(i,j-v) &=max(\ f(i-1,j-v)，f(i-1,j-2v)+w，··· ，f(i-1,j-(s+1)v)+sw\\f(i,j-2v) &=max(\ f(i-1,j-2v)，f(i-1,j-3v)+w，··· ，f(i-1,j-(s+2)v)+sw    \\&······\\j&=r+sv，r=为\ v\ 的余数0，1，2，···，v-1\\所以\ f(i,r+sv) &=max(\ f(i-1,r+sv)，f(i-1,r+(s-1)v)+w，··· ，f(i-1,r)+sw\\f(i,r+(s-1)v) &=max(\ f(i-1,r+(s-1)v)，f(i-1,r+(s-2)v)+w，··· ，f(i-1,r)+(s-1)w\\&······\\f(i,r)&=f(i-1,r)\end{align}</script><p>给每个物品按它的体积 v 的余数分类，余数：[0,v) </p><p>f[0],f[v],f[2v],···,f[kv]  </p><p>f[1],f[1+v],f[1+2v],···,f[1+kv] </p><p>······</p><p>f[j],f[j+v],f[j+2v],···,f[j+kv]</p><p>j 为 v 的余数。f[j+kv]是由前面不超过 s 的同类值传递得到的。</p><p>滑出窗口情况：因为只有s个物品，所以最多 -sv，超过 s 时要出队头，对应体积就是小于 k-sv 之外的要出队。</p><p>时间复杂度 nv(V/v)=nV，O(nV) </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span>f<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 滑动窗口建立在 f 的上一次结果中</span>    cin<span class="token operator">&gt;&gt;</span>v<span class="token operator">&gt;&gt;</span>w<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>v<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">// 拆分成 v 个类</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> hh<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 队列清空</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>k<span class="token operator">+=</span>v<span class="token punctuation">)</span>          <span class="token punctuation">{</span>            <span class="token comment">// 滑出窗口，体积小于全拿时的体积</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token operator">&lt;</span>k<span class="token operator">-</span>s<span class="token operator">*</span>v<span class="token punctuation">)</span> hh<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 用最大值(队头)更新 f，窗口在旧 f 滑动，因此备份 g</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt<span class="token punctuation">)</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>g<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">(</span>k<span class="token operator">-</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span>v<span class="token operator">*</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注</span>            <span class="token comment">// 当前值比队尾的物品个数更好，队尾元素出队</span>            <span class="token comment">// g[q[tt]]-(q[tt]-j)/v*w&lt;=g[k]-(k-j)/v*w</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;=</span>g<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">(</span>k<span class="token operator">-</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span>v<span class="token operator">*</span>w<span class="token punctuation">)</span>  tt<span class="token operator">--</span><span class="token punctuation">;</span>            q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>   <span class="token comment">// 当前值入队</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：为什么选取最大可以放在while前面</p><p>f[i，j]=max(f[i-1，j], f[i-1，j-v]+w, f[i-1，j-2v]+2w… f[i-1，j-sv]+sw)</p><p>g[k]=f[i-1,k]，所以并不会漏掉 f[i-1,j] 项的。放在 q[++tt]=k 后面也没错。</p></blockquote><p>5 <a href="https://www.acwing.com/problem/content/7/">混合背包问题</a>，物品可以用 1 次，$s_i$ 次，无限次。</p><p>分别套用各自的模板</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span>f<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token operator">&gt;&gt;</span>v<span class="token operator">&gt;&gt;</span>w<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 01背包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">// 完全背包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>   <span class="token comment">// 多重背包</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>v<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> hh<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>tt<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>V<span class="token punctuation">;</span>k<span class="token operator">+=</span>v<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token operator">&lt;</span>k<span class="token operator">-</span>s<span class="token operator">*</span>v<span class="token punctuation">)</span> hh<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt<span class="token punctuation">)</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>g<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">(</span>k<span class="token operator">-</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span>v<span class="token operator">*</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>k<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">/</span>v<span class="token operator">*</span>w<span class="token operator">&gt;=</span>g<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">/</span>v<span class="token operator">*</span>w<span class="token punctuation">)</span> tt<span class="token operator">--</span><span class="token punctuation">;</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6 <a href="https://www.acwing.com/problem/content/8/">二维费用的背包问题</a>  </p><p>所选的物品含有两个条件，例如体积和重量，体积和价格。</p><p>例题：有 $N$ 件物品和一个容量是 $V$ 的背包，背包能承受的最大重量是 $M$。每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$ 。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。</p><p>二维 f ，f[i,j]中 i 表示体积，j 表示价值。循环枚举两个费用即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">,</span>m<span class="token punctuation">,</span>w<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>v<span class="token operator">&gt;&gt;</span>m<span class="token operator">&gt;&gt;</span>w<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>V<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>M<span class="token punctuation">;</span>k<span class="token operator">&gt;=</span>m<span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7 费用最多、恰好、至少问题</p><blockquote><p>费用最多是j：常见的背包都是此种情况，全部初始化为 0，不能枚举到 0</p><p>费用恰好是j：f[0]=0, 其他为正无穷，不能枚举到 0</p><p>费用至少是j：f[0]=0, 其他为正无穷，j 可以枚举到 0</p></blockquote><p><a href="https://www.acwing.com/problem/content/1022/">潜水员</a> ：氧气至少是 n，氮气至少是 m，求最小重量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>w<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>a<span class="token operator">&gt;&gt;</span>b<span class="token operator">&gt;&gt;</span>w<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>n<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 可以枚举到 0，j-a&lt;0状态是合法的</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>m<span class="token punctuation">;</span>k<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>            f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">-</span>a<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>k<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>9 背包问题的方案与方案数</p><p><a href="https://www.acwing.com/problem/content/12/">求背包问题的具体方案</a> </p><p>要求输出字典序最小，假设第一个物品在其中一个最优解中，那么该物品必选，然后问题转化为从 [2,n] 中寻找最优解。之前 f[i,j] 保存的是从前 i 个物品选择的最优解，所以在这题中应该表示从 [i,n] 中选择的最优解，所以要倒叙枚举每个物品递推式为：f[i,j]=max( f[i+1,j], f[i+1,j-v[i]]+w[i] )</p><p>在输出时，正着枚举物品；</p><ol><li>$f(i,m)=f(i+1,m-v[i])+w[i]\ \ 且\ \ f(i,m)\ne f(i+1,m)$ : 必须选 i 才能得到最优解</li><li>$f(i,m)\ne f(i+1,m-v[i])+w[i] $ : 任何最优解都不包括 i </li><li>$f(i,m)=f(i+1,m-v[i])+w[i]$ : 最优解可以有 i 也可以没有</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 倒叙求 f </span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">// 输出字典序最小的方案</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>f<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token punctuation">;</span>        j<span class="token operator">-=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/11/">背包问题求方案数</a> </p><p>01 背包求方案数，先用二维数组分析，再按 f 优化的套路优化 g</p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202111232232683.png" alt="ee1acc2660"></p><p>与求最大价值的顺序相同，只是属性变为数量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0x3f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">,</span>w<span class="token punctuation">;</span>  cin<span class="token operator">&gt;&gt;</span>v<span class="token operator">&gt;&gt;</span>w<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>m<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> ma<span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">)</span>     ma<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ma<span class="token punctuation">,</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ma<span class="token operator">==</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> cnt<span class="token operator">=</span>g<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 不选 i 可以到最优解</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&gt;=</span>v<span class="token operator">&amp;&amp;</span>ma<span class="token operator">==</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">)</span>    <span class="token comment">// 选 i 也可以到最优解</span>             cnt<span class="token operator">=</span>cnt<span class="token operator">+</span>g<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>cnt<span class="token operator">%</span>mod<span class="token punctuation">;</span>   f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>ma<span class="token punctuation">;</span>        res<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>ma<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>res<span class="token punctuation">)</span> ans<span class="token operator">=</span><span class="token punctuation">(</span>ans<span class="token operator">+</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果定义为==不恰好==，那么 g[0,i] 都为 0，因为什么都不选对应一个方案。那么 g[i,j] 即为从前 i 个选，体积不超过 j 的最优方案的数量，所以最后 g[n,m]就是答案。</p><p>如果定义为==恰好==，g[0,i]，当 i&gt;1 时，不可能什么都不选但体积不为0，所以只需初始化 g[0,0]=0。答案需要枚举 <strong>体积</strong>，累积价值最大的数量。</p><p>10 <a href="https://www.acwing.com/problem/content/description/489/">金明的预算方案</a> </p><p>物品分为主件和附件，选择附件的前提是已经选择对应的主件，这是有限制的分组背包问题。</p><p>枚举主件物品，设 h 数组为临时数组，临时数组把主件选上，然后将附件视为 01 背包问题，枚举，然后将 h 数组的最大值保存到 f 数组即可。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>z<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历主件</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> v1<span class="token operator">=</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span>p1<span class="token operator">=</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">,</span>id<span class="token operator">=</span>z<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v1<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 选上主件 初始化 f </span>        h<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>j<span class="token operator">-</span>v1<span class="token punctuation">]</span><span class="token operator">+</span>p1<span class="token operator">*</span>v1<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>fu<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 遍历附件，已满足前提</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> v2<span class="token operator">=</span>fu<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> p2<span class="token operator">=</span>fu<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>n<span class="token punctuation">;</span> k<span class="token operator">&gt;=</span>v1<span class="token operator">+</span>v2<span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">// 01背包</span>            h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>h<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>h<span class="token punctuation">[</span>k<span class="token operator">-</span>v2<span class="token punctuation">]</span><span class="token operator">+</span>v2<span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>v1<span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>h<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>11 <a href="https://www.acwing.com/problem/content/10/">有依赖的背包问题</a> </p><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" alt="image-20211125210142607"> </p><p>对于父结点 x，将它体积作为分组对象，分为 0，1，···，m-v[x]。每次只能选择一个体积去做 <strong>分组</strong> 背包。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> mx<span class="token punctuation">)</span> <span class="token comment">// mx 表示父结点 x 以及子结点可用的体积</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>mx<span class="token operator">-</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>mx<span class="token operator">-</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">// 先给 x 腾出来空</span>            <span class="token comment">// 一次只能选取一个体积,一种体积代表一种最大组合</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>j<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>     f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 最后考虑根节点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>mx<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>   <span class="token comment">// 选上 x </span>        f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 选不下，因此要置 0</span><span class="token punctuation">}</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>f<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> mx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 先把根节点放进去</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>mx<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> y<span class="token operator">=</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>mx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>mx<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">// 开始分组背包</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">// 枚举每一种体积</span>                f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2 背包容量很大问题：</p><p>转换体积和价值，f[i] 表示价值为 i 时的最小体积。</p><h3 id="4-状态机模型"><a href="#4-状态机模型" class="headerlink" title="4 状态机模型"></a>4 状态机模型</h3><blockquote><p>状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv</title>
      <link href="/shen-du-xue-xi/opencv/"/>
      <url>/shen-du-xue-xi/opencv/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="Opencv学习"><a href="#Opencv学习" class="headerlink" title="Opencv学习"></a>Opencv学习</h1><h2 id="1-图像的基本操作"><a href="#1-图像的基本操作" class="headerlink" title="1 图像的基本操作"></a>1 图像的基本操作</h2><h3 id="1-1-读取操作"><a href="#1-1-读取操作" class="headerlink" title="1.1 读取操作"></a>1.1 读取操作</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2         <span class="token comment"># 导入 opencv 库  BGR</span><span class="token comment"># 绘图库, plt和cv2显示格式不同:RGB , 需要指定参数 'gray'</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt   <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np     <span class="token comment"># 矩阵运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 0 表示按任意键终止，否则指定 ms 后终止</span>cv2<span class="token punctuation">.</span>destroyALLWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>img<span class="token punctuation">.</span>shape    <span class="token comment"># 返回 （H, W, C）, 高，宽，通道</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'**.png'</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span>  <span class="token comment"># 保存</span>img<span class="token punctuation">.</span>size     <span class="token comment"># img 像素点的个数 H*W</span>img<span class="token punctuation">.</span>dtype    <span class="token comment"># 编码类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取视频</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'test.mp4'</span><span class="token punctuation">)</span><span class="token comment"># 检查打开是否正确</span><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">open</span><span class="token punctuation">,</span> frame <span class="token operator">=</span> vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 返回是否打开正确和第一帧</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token builtin">open</span> <span class="token operator">=</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截取部分图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">result_img <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>img_B<span class="token punctuation">,</span> img_G<span class="token punctuation">,</span> img_R <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span> <span class="token comment"># 按三通道分开</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">(</span>img_B<span class="token punctuation">,</span> img_G<span class="token punctuation">,</span> img_R<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 合并回原图象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-2-边界填充"><a href="#1-2-边界填充" class="headerlink" title="1.2 边界填充"></a>1.2 边界填充</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"imgs/dog2.jpg"</span><span class="token punctuation">)</span><span class="token comment"># 将 BGR 改为 RGB 以便 plt 显示</span>b<span class="token punctuation">,</span> g<span class="token punctuation">,</span> r <span class="token operator">=</span> cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 设置填充大小</span>top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token comment"># 复制最边缘像素</span>replicate <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size<span class="token punctuation">,</span> borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span><span class="token comment"># 反射，对称复制过去</span>reflect <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size<span class="token punctuation">,</span> borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span><span class="token comment"># 反射，以最边缘像素为轴，对称过去以达到填充效果</span>reflect101 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size<span class="token punctuation">,</span> borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span><span class="token comment"># 外包装法，不对成，直接平移</span>wrap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size<span class="token punctuation">,</span> borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span><span class="token comment"># 常数数值填充</span>constant <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top_size<span class="token punctuation">,</span> bottom_size<span class="token punctuation">,</span> left_size<span class="token punctuation">,</span> right_size<span class="token punctuation">,</span> borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">)</span><span class="token comment"># 输出格式</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Original"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>replicate<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Replicate"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>reflect<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Reflect"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>reflect101<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Reflect101"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>wrap<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Wrap"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>constant<span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Constant"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112212020711.png" alt="image-20211221202040331"></p><h3 id="1-3-图像矩阵计算"><a href="#1-3-图像矩阵计算" class="headerlink" title="1.3 图像矩阵计算"></a>1.3 图像矩阵计算</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> img1 <span class="token operator">+</span> <span class="token number">10</span>  <span class="token comment"># 矩阵每个值都加 10</span>img <span class="token operator">=</span> img1 <span class="token operator">+</span> img2  <span class="token comment"># 矩阵数值相加 % 256</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-4-图像融合"><a href="#1-4-图像融合" class="headerlink" title="1.4 图像融合"></a>1.4 图像融合</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># resize 后两个图像矩阵相加</span><span class="token comment"># 给予权重相加</span><span class="token comment"># res = a*img1 + b*img2 + gamma, gamma提高亮度</span>res <span class="token operator">=</span> cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> img2<span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112212058045.png" alt="image-20211221205846882"></p><h3 id="1-5-图像阈值与二值化"><a href="#1-5-图像阈值与二值化" class="headerlink" title="1.5 图像阈值与二值化"></a>1.5 图像阈值与二值化</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 二值化</span>ret<span class="token punctuation">,</span> dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span> thresh<span class="token punctuation">,</span> maxval<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>src: 输入图像</p><p>thresh: 阈值</p><p>maxval: 当像素超过或小于阈值（根据type）来定，赋值为maxval</p><p>type: 二值化类型，通常有一下五种</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>THRESH_BINARY <span class="token operator">=</span> <span class="token number">0</span>     <span class="token comment"># 大于阈值取 maxval，否则取 0</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment"># 小于阈值取 0， 否则取maxval</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC <span class="token operator">=</span> <span class="token number">2</span>      <span class="token comment"># 大于阈值部分取阈值，否则不变</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO <span class="token operator">=</span> <span class="token number">3</span>     <span class="token comment"># 大于阈值部分不变，否则取 0</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment"># 小于阈值部分不变，否则取 maxval</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-图像平滑处理"><a href="#1-6-图像平滑处理" class="headerlink" title="1.6 图像平滑处理"></a>1.6 图像平滑处理</h3><p><strong>低频分量(低频信号)</strong>：代表着图像中亮度或者灰度值变化缓慢的区域，也就是图像中大片平坦的区域，描述了图像的主要部分，是对整幅图像强度的综合度量。</p><p><strong>高频分量(高频信号)</strong>：对应着图像变化剧烈的部分，也就是图像的边缘（轮廓）或者噪声以及细节部分。 主要是对图像边缘和轮廓的度量，而人眼对高频分量比较敏感。之所以说噪声也对应着高频分量，是因为图像噪声在大部分情况下都是高频的。</p><h4 id="1-6-1-均值滤波"><a href="#1-6-1-均值滤波" class="headerlink" title="1.6.1 均值滤波"></a>1.6.1 均值滤波</h4><p>是一个卷积的过程。目标像素的邻域内的所有像素和取平均值。</p><p> <img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/202112291249556.jpeg" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># src 为原图像</span><span class="token comment"># ksize 为卷积核的大小如上图，ksize = 3</span><span class="token comment"># dst 为输出图像的赋值对象，一般不管它</span>cv2<span class="token punctuation">.</span>medianBlur<span class="token punctuation">(</span>src<span class="token punctuation">,</span> ksize<span class="token punctuation">,</span> dst<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>1.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/c/cmake-jiao-cheng/"/>
      <url>/c/cmake-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="1-CMake概述"><a href="#1-CMake概述" class="headerlink" title="1. CMake概述"></a>1. CMake概述</h1><p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p><p>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：</p><p><img src="imgs/cmake编译流程.png" alt="Alt text"></p><ul><li>蓝色虚线表示使用makefile构建项目的过程</li><li>红色实线表示使用cmake构建项目的过程</li><li><p>介绍完CMake的作用之后，再来总结一下它的优点：</p></li><li><p>跨平台</p></li><li>能够管理大型项目</li><li>简化编译构建过程和编译过程</li><li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li></ul><h1 id="2-CMake的使用"><a href="#2-CMake的使用" class="headerlink" title="2 CMake的使用"></a>2 CMake的使用</h1><h2 id="2-1-注释方法"><a href="#2-1-注释方法" class="headerlink" title="2.1 注释方法"></a>2.1 注释方法</h2><p> <strong>#</strong> 和 <strong>#[[]]</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 这是一个 CMakeLists.txt 文件</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0.0</span><span class="token punctuation">)</span><span class="token comment">#[[ 这是一个 CMakeLists.txt 文件。</span>这是一个 CMakeLists.txt 文件这是一个 CMakeLists.txt 文件]]<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0.0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-CMakeLists-txt-命令"><a href="#2-2-CMakeLists-txt-命令" class="headerlink" title="2.2 CMakeLists.txt 命令"></a>2.2 CMakeLists.txt 命令</h2><h3 id="2-2-1-基本命令"><a href="#2-2-1-基本命令" class="headerlink" title="2.2.1 基本命令"></a>2.2.1 基本命令</h3><ul><li>cmake_minimum_required：指定使用的 cmake 的最低版本</li></ul><ul><li><p>project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># PROJECT 指令的语法是：</span><span class="token keyword">project</span><span class="token punctuation">(</span>&lt;PROJECT-<span class="token property">NAME</span><span class="token punctuation">&gt;</span> [&lt;language-name<span class="token punctuation">&gt;</span>...]<span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>&lt;PROJECT-<span class="token property">NAME</span><span class="token punctuation">&gt;</span>       [<span class="token property">VERSION</span> &lt;major<span class="token punctuation">&gt;</span>[.&lt;minor<span class="token punctuation">&gt;</span>[.&lt;patch<span class="token punctuation">&gt;</span>[.&lt;tweak<span class="token punctuation">&gt;</span>]]]]       [DESCRIPTION &lt;project-description-string<span class="token punctuation">&gt;</span>]       [HOMEPAGE_URL &lt;url-string<span class="token punctuation">&gt;</span>]       [LANGUAGES &lt;language-name<span class="token punctuation">&gt;</span>...]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>add_executable：定义工程会生成一个可执行程序<br>源文件名可以是一个也可以是多个，如有多个可用空格或;间隔</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 样式1</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app add.c div.c main.c mult.c sub.c<span class="token punctuation">)</span><span class="token comment"># 样式2</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app add.c;div.c;main.c;mult.c;sub.c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-SET-用法"><a href="#2-2-SET-用法" class="headerlink" title="2.2 SET 用法"></a>2.2 SET 用法</h2><h3 id="2-2-1-SET使用方法"><a href="#2-2-1-SET使用方法" class="headerlink" title="2.2.1 SET使用方法"></a>2.2.1 SET使用方法</h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。</p></li></ul><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># SET 指令的语法是：</span><span class="token comment"># [] 中的参数为可选项, 如不需要可以不写</span><span class="token function">SET</span><span class="token punctuation">(</span>VAR [<span class="token property">VALUE</span>] [<span class="token variable">CACHE</span> <span class="token property">TYPE</span> DOCSTRING [FORCE]]<span class="token punctuation">)</span><span class="token comment"># VAR 变量名, VALUE 变量值</span><span class="token comment"># 对变量进行取值,massage 是打印</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token punctuation">${</span>VAR<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以一下赋值很多个元素<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 方式1: 各个源文件之间使用空格间隔</span><span class="token keyword">set</span><span class="token punctuation">(</span>SRC_LIST add.c  div.c   main.c  mult.c  sub.c<span class="token punctuation">)</span><span class="token comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span><span class="token keyword">set</span><span class="token punctuation">(</span>SRC_LIST add.c;div.c;main.c;mult.c;sub.c<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app  <span class="token punctuation">${</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="2-2-2-SET-用于制定使用-C-标准"><a href="#2-2-2-SET-用于制定使用-C-标准" class="headerlink" title="2.2.2 SET 用于制定使用 C++ 标准"></a>2.2.2 SET 用于制定使用 C++ 标准</h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：<br></p><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">$ g++ *.cpp -std=c++11 -o app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>上面的例子中通过参数 -std=c++11 指定出要使用 c++11 标准编译程序，C++标准对应有一宏叫做<strong>DCMAKE_CXX_STANDARD</strong>,cmake默认C++98。在CMake中想要指定C++标准有两种方式：<p></p><ol><li>在 CMakeLists.txt 中通过 set 命令指定 <pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#增加-std=c++11</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>  <span class="token comment"># C++ 11 是强制要求，不会衰退至低版本</span><span class="token comment">#增加-std=c++14</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token comment">#增加-std=c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在执行 cmake 命令的时候指定出这个变量的值 <pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">#增加-std=c++11cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11#增加-std=c++14cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14#增加-std=c++17cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3-SET-指定输出的路径"><a href="#2-2-3-SET-指定输出的路径" class="headerlink" title="2.2.3 SET 指定输出的路径"></a>2.2.3 SET 指定输出的路径</h3></li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 设置生成的可执行文件的输出路径</span><span class="token function">SET</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">${</span><span class="token variable">PROJECT_BINARY_DIR</span><span class="token punctuation">}</span>/bin<span class="token punctuation">)</span><span class="token comment"># PROJECT_BINARY_DIR, 就是CMakeLists.txt 所在的目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-3-搜索文件命令"><a href="#2-3-搜索文件命令" class="headerlink" title="2.3 搜索文件命令"></a>2.3 搜索文件命令</h2><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。</p><p><strong>aux_source_directory</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>&lt; dir <span class="token punctuation">&gt;</span> &lt; variable <span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span class="token comment"># 搜索 src 目录下的源文件</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/src SRC_LIST<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app  <span class="token punctuation">${</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径<p></p><p><strong>file</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型<span class="token punctuation">)</span><span class="token comment"># GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</span><span class="token comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB MAIN_SRC <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/src/*.cpp<span class="token punctuation">)</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB MAIN_HEAD <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/include/*.h<span class="token punctuation">)</span><span class="token comment">#关于要搜索的文件路径和类型可加双引号，也可不加:</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB MAIN_HEAD <span class="token string">"<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span></span>/src/*.h"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="2-4-包含头文件"><a href="#2-4-包含头文件" class="headerlink" title="2.4 包含头文件"></a>2.4 包含头文件</h2><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是include_directories:<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">include_directories</span><span class="token punctuation">(</span>headpath<span class="token punctuation">)</span><span class="token comment"># 头文件目录包含进去</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h2 id="2-5-制作动态库或静态库"><a href="#2-5-制作动态库或静态库" class="headerlink" title="2.5  制作动态库或静态库"></a>2.5  制作动态库或静态库</h2><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h3 id="2-5-1-静态库"><a href="#2-5-1-静态库" class="headerlink" title="2.5.1 静态库"></a>2.5.1 静态库</h3><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>库名称 <span class="token namespace">STATIC</span> 源文件<span class="token number">1</span> [源文件<span class="token number">2</span>] ...<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例如</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>CALC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB SRC_LIST <span class="token string">"<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span></span>/src/*.cpp"</span><span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span>calc <span class="token namespace">STATIC</span> <span class="token punctuation">${</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>执行完毕后,会生成 libcalc.a 静态库<p></p><h3 id="2-5-2-动态库"><a href="#2-5-2-动态库" class="headerlink" title="2.5.2 动态库"></a>2.5.2 动态库</h3><p><strong>更常用</strong><br>用 gcc -fPIC -shared</p><p>在cmake中，如果要制作动态库，需要使用的命令如下：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_library</span><span class="token punctuation">(</span>库名称 <span class="token namespace">SHARED</span> 源文件<span class="token number">1</span> [源文件<span class="token number">2</span>] ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成对应的动态库文件libcalc.so,动态库是可以执行的</p><h3 id="2-5-3-指定库的输出路径"><a href="#2-5-3-指定库的输出路径" class="headerlink" title="2.5.3 指定库的输出路径"></a>2.5.3 指定库的输出路径</h3><p>仅适用于<strong>动态库</strong>:<br>对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录：<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>适用于<strong>静态库</strong>和<strong>动态库</strong><br>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。<br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="2-5-3-静态库和动态库的优劣"><a href="#2-5-3-静态库和动态库的优劣" class="headerlink" title="2.5.3 静态库和动态库的优劣"></a>2.5.3 静态库和动态库的优劣</h3><p><strong>静态库</strong><br>优点：  </p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点：  </p><ul><li>相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存</li><li>库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。</li></ul><p><strong>动态库</strong><br>优点：  </p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单, 只需要替换库文件, 无需重新编译应用程序</li><li>程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载</li><li>动态库在内存中只有一份拷贝,避免了静态库浪费空间的问题</li></ul><p>缺点：  </p><ul><li>加载速度比静态库慢, 但以现在计算机的性能可以忽略</li><li>发布程序需要提供依赖的动态库</li></ul><h2 id="2-6-在程序中链接库"><a href="#2-6-在程序中链接库" class="headerlink" title="2.6 在程序中链接库"></a>2.6 在程序中链接库</h2><h3 id="2-6-1-链接静态库"><a href="#2-6-1-链接静态库" class="headerlink" title="2.6.1 链接静态库"></a>2.6.1 链接静态库</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 静态库的名字 要链接的其它静态库的名字</span><span class="token keyword">link_libraries</span><span class="token punctuation">(</span>&lt;static lib<span class="token punctuation">&gt;</span> [&lt;static lib<span class="token punctuation">&gt;</span>...]<span class="token punctuation">)</span><span class="token comment"># 包含静态库路径</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span class="token comment"># 链接静态库,可以是 libcalc.a 也可以是 calc</span><span class="token keyword">link_libraries</span><span class="token punctuation">(</span>calc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-2-链接动态库"><a href="#2-6-2-链接动态库" class="headerlink" title="2.6.2 链接动态库"></a>2.6.2 链接动态库</h3><p>在cmake中链接动态库的命令如下:<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>    &lt;target<span class="token punctuation">&gt;</span>     &lt;<span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span><span class="token punctuation">&gt;</span> &lt;item<span class="token punctuation">&gt;</span>...     [&lt;<span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span><span class="token punctuation">&gt;</span> &lt;item<span class="token punctuation">&gt;</span>...]...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>target：指定要加载动态库的文件的名字  <p></p><ul><li>该文件可能是一个源文件</li><li>该文件可能是一个动态库文件</li><li>该文件可能是一个可执行文件</li></ul><p>PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC</p><ul><li>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可</li><li>动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>A B C<span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>D A<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。</li><li>PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库,不具有传递性了,只能传递就近的一次</li><li>INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</li></ul><p>动态库的链接和静态库是完全不同的：</p><ol><li>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</li><li>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</li></ol><p>因此，在cmake中指定要链接的动态库的时候，先生成可执行文件,再把动态库链接上去,应该将命令<strong>写在生成可执行文件之后</strong>:</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>TEST<span class="token punctuation">)</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB SRC_LIST <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/*.cpp<span class="token punctuation">)</span><span class="token comment"># 添加并指定最终生成的可执行程序名</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app <span class="token punctuation">${</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment"># 指定可执行程序要链接的动态库名字</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>app pthread<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在target_link_libraries(app pthread)中：</p><ul><li>app: 对应的是最终生成的可执行程序的名字</li><li>pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。</li></ul><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 指定要链接的动态库的路径</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span class="token comment"># 添加并生成一个可执行程序</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>app <span class="token punctuation">${</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment"># 既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>app pthread calc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用 target_link_libraries 命令可以链接动态库，也可以链接静态库文件</strong></p><h2 id="2-7-日志"><a href="#2-7-日志" class="headerlink" title="2.7 日志"></a>2.7 日志</h2><p><strong>message</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">message</span><span class="token punctuation">(</span>[STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="token string">"message to display"</span> ...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>(无) ：重要消息</li><li>STATUS ：非重要消息</li><li>WARNING：CMake 警告, 会继续执行</li><li>AUTHOR_WARNING：CMake 警告 (dev), 会继续执行</li><li>SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤</li><li>FATAL_ERROR：CMake 错误, 终止所有处理过程</li></ul><p>CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p><h2 id="2-8-变量操作"><a href="#2-8-变量操作" class="headerlink" title="2.8 变量操作"></a>2.8 变量操作</h2><h3 id="2-8-1-追加"><a href="#2-8-1-追加" class="headerlink" title="2.8.1 追加"></a>2.8.1 追加</h3><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。</p><p><strong>使用 set</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>变量名<span class="token number">1</span> <span class="token punctuation">${</span>变量名<span class="token number">1</span><span class="token punctuation">}</span> <span class="token punctuation">${</span>变量名<span class="token number">2</span><span class="token punctuation">}</span> ...<span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>SRC_1 <span class="token punctuation">${</span>SRC_1<span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>TEMP<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖.<p></p><p><strong>使用 list</strong>  </p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">list</span><span class="token punctuation">(</span>APPEND &lt;list<span class="token punctuation">&gt;</span> [&lt;element<span class="token punctuation">&gt;</span> ...]<span class="token punctuation">)</span><span class="token keyword">list</span><span class="token punctuation">(</span>APPEND SRC_1 <span class="token punctuation">${</span>SRC_1<span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>TEMP<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。</p><p><strong>注意</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">set</span><span class="token punctuation">(</span>tmp1 a;b;c;d;e<span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>tmp2 a b c d e<span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token punctuation">${</span>tmp1<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span><span class="token punctuation">${</span>tmp2<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment"># abcde</span><span class="token comment"># abcde</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>打印的结果 是 abcde,看不到空格或分号,但底层管理是有分号的,分开的<p></p><h3 id="2-8-2-移除"><a href="#2-8-2-移除" class="headerlink" title="2.8.2 移除"></a>2.8.2 移除</h3><p>我们在通过file搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的,比如：<br></p><pre class="line-numbers language-none"><code class="language-none">src──    ├── add.cpp    ├── div.cpp    ├── main.cpp    ├── mult.cpp    └── sub.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>只需要add.cpp、div.cp、mult.cpp、sub.cpp这四个源文件就可以了,此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list<br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">list</span><span class="token punctuation">(</span>REMOVE_ITEM &lt;list<span class="token punctuation">&gt;</span> &lt;value<span class="token punctuation">&gt;</span> [&lt;value<span class="token punctuation">&gt;</span> ...]<span class="token punctuation">)</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB SRC_1 <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/*.cpp<span class="token punctuation">)</span><span class="token comment"># 移除前日志</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"message: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">SRC_1</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token comment"># 移除 main.cpp,</span><span class="token keyword">list</span><span class="token punctuation">(</span>REMOVE_ITEM SRC_1 <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。<p></p><h3 id="2-8-2-其他操作"><a href="#2-8-2-其他操作" class="headerlink" title="2.8.2 其他操作"></a>2.8.2 其他操作</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">list</span><span class="token punctuation">(</span>LENGTH &lt;list<span class="token punctuation">&gt;</span> &lt;output variable<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">list</span> <span class="token punctuation">(</span>APPEND &lt;list<span class="token punctuation">&gt;</span> [&lt;element<span class="token punctuation">&gt;</span> ...]<span class="token punctuation">)</span><span class="token keyword">list</span> <span class="token punctuation">(</span>REMOVE_DUPLICATES &lt;list<span class="token punctuation">&gt;</span><span class="token punctuation">)</span>...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-9-宏定义"><a href="#2-9-宏定义" class="headerlink" title="2.9 宏定义"></a>2.9 宏定义</h2><p><strong>场景</strong></p><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#define NUMBER  3int main(){    int a = 10;#ifdef DEBUG    printf("我是一个程序猿, 我不会爬树...\n");#endif    for(int i=0; i&lt;NUMBER; ++i)    {        printf("hello, GCC!!!\n");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在gcc/g++命令中去指定宏:<br><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">gcc test.c -DDEBUG -o app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>在 cmake 中 指定宏<br><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-D宏名称<span class="token punctuation">)</span><span class="token comment"># 针对上面代码</span><span class="token keyword">add_definitions</span><span class="token punctuation">(</span>-DDEBUG<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>预定义的变量<p></p><div class="table-container"><table><thead><tr><th>宏</th><th>功能</th></tr></thead><tbody><tr><td>PROJECT_SOURCE_DIR</td><td>使用cmake命令后紧跟的目录，一般是工程的根目录</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>执行cmake命令的目录</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>当前处理的CMakeLists.txt所在的路径</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>target 编译目录</td></tr><tr><td>EXECUTABLE_OUTPUT_PATH</td><td>重新定义目标二进制可执行文件的存放位置</td></tr><tr><td>LIBRARY_OUTPUT_PATH</td><td>重新定义目标链接库文件的存放位置</td></tr><tr><td>PROJECT_NAME</td><td>返回通过PROJECT指令定义的项目名称</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>项目实际构建路径，假设在build目录进行的构建，那么得到的,就是这个目录的路径</td></tr></tbody></table></div><h1 id="3-嵌套的-cmake"><a href="#3-嵌套的-cmake" class="headerlink" title="3 嵌套的 cmake"></a>3 嵌套的 cmake</h1><h2 id="3-1-构建目录"><a href="#3-1-构建目录" class="headerlink" title="3.1 构建目录"></a>3.1 构建目录</h2><p>如果项目<strong>很大</strong>，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p><pre class="line-numbers language-none"><code class="language-none">$ tree.├── build├── calc│&nbsp;&nbsp; ├── add.cpp│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── div.cpp│&nbsp;&nbsp; ├── mult.cpp│&nbsp;&nbsp; └── sub.cpp├── CMakeLists.txt├── include│&nbsp;&nbsp; ├── calc.h│&nbsp;&nbsp; └── sort.h├── sort│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── insert.cpp│&nbsp;&nbsp; └── select.cpp├── test1│&nbsp;&nbsp; ├── calc.cpp│&nbsp;&nbsp; └── CMakeLists.txt└── test2    ├── CMakeLists.txt    └── sort.cpp6 directories, 15 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息：</p><ul><li>根节点CMakeLists.txt中的变量全局有效</li><li>父节点CMakeLists.txt中的变量可以在子节点中使用</li><li>子节点CMakeLists.txt中的变量只能在当前节点中使用</li></ul><p><strong>构建父子节点关系</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>source_dir [binary_dir] [<span class="token property">EXCLUDE_FROM_ALL</span>]<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ul><li>source_dir：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录</li><li>binary_dir：指定了输出文件的路径，一般不需要指定，忽略即可。</li><li>EXCLUDE_FROM_ALL：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li></ul><p><strong>提出问题</strong><br>在上面的目录中我们要做如下事情：</p><ol><li>通过 test1 目录中的测试文件进行计算器相关的测试</li><li>通过 test2 目录中的测试文件进行排序相关的测试  </li></ol><p>现在相当于是要进行模块化测试，对于calc和sort目录中的源文件来说，可以将它们先<strong>编译成库文件</strong>（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p><p><strong>根目录</strong><br>先编译 父CMakeLists.txt, 然后编译子 CMakeLists.txt<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token comment"># 定义变量</span><span class="token comment"># 静态库生成的路径</span><span class="token keyword">set</span><span class="token punctuation">(</span>LIB_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/lib<span class="token punctuation">)</span><span class="token comment"># 测试程序生成的路径</span><span class="token keyword">set</span><span class="token punctuation">(</span>EXEC_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/bin<span class="token punctuation">)</span><span class="token comment"># 头文件目录</span><span class="token keyword">set</span><span class="token punctuation">(</span>HEAD_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/include<span class="token punctuation">)</span><span class="token comment"># 静态库的名字</span><span class="token keyword">set</span><span class="token punctuation">(</span>CALC_LIB calc<span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>SORT_LIB sort<span class="token punctuation">)</span><span class="token comment"># 可执行程序的名字</span><span class="token keyword">set</span><span class="token punctuation">(</span>APP_NAME_1 test1<span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span>APP_NAME_2 test2<span class="token punctuation">)</span><span class="token comment"># 添加子目录</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>calc<span class="token punctuation">)</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>sort<span class="token punctuation">)</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>test1<span class="token punctuation">)</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>test2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>calc 目录</strong><br>生成动态库<br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>CALCLIB<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span>CALC_LIB<span class="token punctuation">}</span> <span class="token namespace">STATIC</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>sort目录</strong><br>生成动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>SORTLIB<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span>SORT_LIB<span class="token punctuation">}</span> <span class="token namespace">SHARED</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test1 目录</strong><br>链接动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>CALCTEST<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">${</span>CALC_LIB<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">${</span>EXEC_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span>APP_NAME_1<span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>test2 目录</strong><br>链接动态库</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>SORTTEST<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">${</span>EXEC_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span>APP_NAME_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">${</span>APP_NAME_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>SORT_LIB<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-静态库中链接静态库"><a href="#3-2-静态库中链接静态库" class="headerlink" title="3.2 静态库中链接静态库"></a>3.2 静态库中链接静态库</h2><p>生成静态库前要先 link 依赖的静态库</p><p><strong>sort</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>SORTLIB<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>LIBPATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">${</span>CALC_LIB<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">LIBRARY_OUTPUT_PATH</span> <span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span>SORT_LIB<span class="token punctuation">}</span> <span class="token namespace">STATIC</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>test2</strong><br></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>SORTTEST<span class="token punctuation">)</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>./ SRC<span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>HEAD_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">EXECUTABLE_OUTPUT_PATH</span> <span class="token punctuation">${</span>EXEC_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span>LIB_PATH<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span>APP_NAME_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">${</span>APP_NAME_2<span class="token punctuation">}</span> <span class="token punctuation">${</span>SORT_LIB<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h1 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4 流程控制"></a>4 流程控制</h1><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;condition<span class="token punctuation">&gt;</span><span class="token punctuation">)</span>  &lt;commands<span class="token punctuation">&gt;</span><span class="token keyword">elseif</span><span class="token punctuation">(</span>&lt;condition<span class="token punctuation">&gt;</span><span class="token punctuation">)</span> <span class="token comment"># 可选快, 可以重复</span>  &lt;commands<span class="token punctuation">&gt;</span><span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment"># 可选快</span>  &lt;commands<span class="token punctuation">&gt;</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">NOT</span> &lt;condition<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;cond1<span class="token punctuation">&gt;</span> <span class="token operator">AND</span> &lt;cond2<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;cond1<span class="token punctuation">&gt;</span> <span class="token operator">OR</span> &lt;cond2<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;variable|string<span class="token punctuation">&gt;</span> <span class="token operator">STRLESS</span> &lt;variable|string<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;variable|string<span class="token punctuation">&gt;</span> <span class="token operator">STRGREATER</span> &lt;variable|string<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;variable|string<span class="token punctuation">&gt;</span> <span class="token operator">STREQUAL</span> &lt;variable|string<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;variable|string<span class="token punctuation">&gt;</span> STRLESS_EQUAL &lt;variable|string<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>&lt;variable|string<span class="token punctuation">&gt;</span> STRGREATER_EQUAL &lt;variable|string<span class="token punctuation">&gt;</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>EXISTS path-to-file-or-directory<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>IS_DIRECTORY path<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>IS_SYMLINK file-name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-循环"><a href="#4-2-循环" class="headerlink" title="4.2 循环"></a>4.2 循环</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">foreach</span><span class="token punctuation">(</span>&lt;loop_var<span class="token punctuation">&gt;</span> &lt;items<span class="token punctuation">&gt;</span><span class="token punctuation">)</span>    &lt;commands<span class="token punctuation">&gt;</span><span class="token keyword">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.2</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token comment"># 循环</span><span class="token keyword">foreach</span><span class="token punctuation">(</span>item RANGE <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"当前遍历的值为: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">item</span><span class="token punctuation">}</span></span>"</span> <span class="token punctuation">)</span><span class="token keyword">endforeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>    &lt;target<span class="token punctuation">&gt;</span>     &lt;<span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span><span class="token punctuation">&gt;</span> &lt;item<span class="token punctuation">&gt;</span>...     [&lt;<span class="token namespace">PRIVATE</span>|<span class="token namespace">PUBLIC</span>|<span class="token namespace">INTERFACE</span><span class="token punctuation">&gt;</span> &lt;item<span class="token punctuation">&gt;</span>...]...<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既可以链接静态库也可以连接静态库,但使用的时候要放在 add_executable()下面</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf</title>
      <link href="/c/protobuf-jiao-cheng/"/>
      <url>/c/protobuf-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Protobuf介绍"><a href="#1-Protobuf介绍" class="headerlink" title="1 Protobuf介绍"></a>1 Protobuf介绍</h1><p>类似 xml,json的数据格式,是一种二进制而是,比 xml,json 快很多</p><h1 id="2-使用流程"><a href="#2-使用流程" class="headerlink" title="2 使用流程"></a>2 使用流程</h1><ol><li><p>确定数据格式，数据可简单可复杂，比如：</p> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 要序列化的数据// 第一种: 单一数据类型int number;// 第二种: 复合数据类型struct Person{    int id;    string name;    string sex;    int age;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建一个新的文件, 文件名随意指定, 文件后缀为 .proto</p></li><li>根据protobuf的语法, 编辑.proto文件</li><li>使用 protoc 命令将 .proto 文件转化为相应的 C++ 文件</li></ol><ul><li>源文件: xxx.pb.cc –&gt; xxx对应的名字和 .proto文件名相同</li><li>头文件: xxx.pb.h –&gt; xxx对应的名字和 .proto文件名相同</li></ul><ol><li>需要将生成的c++文件添加到项目中, 通过文件中提供的类 API 实现数据的序列化/反序列化</li></ol><p><strong>protobuf中的数据类型 和 C++ 数据类型对照表:</strong><br>|Protobuf 类型  | C++ 类型  | 备注|<br>|—|—|—|<br>|double  | double  | 64位浮点数|<br>|float  | float  | 32位浮点数|<br>|int32  | int  | 32位整数|<br>|int64  | long  | 64位整数|<br>|uint32  | unsigned int  | 32位无符号整数|<br>|uint64  | unsigned long  | 64位无符号整数|<br>|sint32  | signed int  | 32位整数，处理负数效率比int32更高|<br>|sint64  | signed long  | 64位整数，处理负数效率比int64更高|<br>|fixed32  | unsigned int(32位)  | 总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。|<br>|fixed64  | unsigned long(64位)  | 总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。|<br>|sfixed32  | int (32位)  | 总是4个字节|<br>|sfixed64  | long (64位)  | 总是8个字节|<br>|bool  | bool  | 布尔类型|<br>|string  | string  | 一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本|<br>|bytes  | string  | 处理多字节的语言字符、如中文, 建议protobuf中字符型类型使用 bytes|<br>|enum  | enum  | 枚举|<br>|message  | object of class  | 自定义的消息类型|</p><h1 id="3-Protobuf-的使用"><a href="#3-Protobuf-的使用" class="headerlink" title="3 Protobuf 的使用"></a>3 Protobuf 的使用</h1><p>定义了这样一个结构体，现在要基于这个结构体完成数据的序列化，结构体原型如下：<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Person{    int id;    string name;    string sex;// man woman    int age;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>新建一个文件，给它起个名字，后缀指定为 .proto，在文件的第一行需要指定Protobuf的版本号，有两个版本Protobuf 2 和 Protobuf 3，此处我们使用的是版本3。<br></p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">// Person.proto</span><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment">// 在该文件中对要序列化的结构体进行描述</span><span class="token keyword">message</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token builtin">int32</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> sex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// message 名字</span><span class="token comment">// {</span><span class="token comment">//    // 类中的成员, 格式</span><span class="token comment">//    数据类型 成员名字 = 1;</span><span class="token comment">//    数据类型 成员名字 = 2;</span><span class="token comment">//    数据类型 成员名字 = 3;</span><span class="token comment">//   ......     </span><span class="token comment">//   ......</span><span class="token comment">// }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>.proto文件编辑好之后就可以使用protoc工具将其转换为C++文件<br></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">protoc -I path .proto文件 --cpp_out=输出路径(存储生成的c++文件)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>在 protoc 命令中，-I 参数后面可以跟随一个或多个路径，用于告诉编译器在哪些路径下查找导入的文件或依赖的文件，使用绝对路径或相对路径都是没问题的。<br>protoc -I path1 -I path2 或 protoc -I path1:path2<p></p><h2 id="3-1-常见数据表示"><a href="#3-1-常见数据表示" class="headerlink" title="3.1  常见数据表示"></a>3.1  常见数据表示</h2><p>在使用Protocol Buffers（Protobuf）中，可以使用repeated关键字作为限定修饰符来表示一个字段可以有多个值，即重复出现的字段。repeated关键字可以用于以下数据类型：基本数据类型、枚举类型和自定义消息类型</p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">// 要序列化的数据</span>struct Person<span class="token punctuation">{</span>    <span class="token positional-class-name class-name">int</span> id<span class="token punctuation">;</span>    <span class="token builtin">string</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token builtin">string</span> sex<span class="token punctuation">;</span>    <span class="token positional-class-name class-name">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// Protobuf 的消息体就可以写成下面的样子:</span><span class="token keyword">message</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token builtin">int32</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">repeated</span> <span class="token builtin">bytes</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> sex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>枚举</strong></p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token comment">// 要序列化的数据</span><span class="token comment">// 枚举</span><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    Red <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token comment">// 可以不给初始值, 默认为0</span>    Green<span class="token punctuation">,</span>    Yellow<span class="token punctuation">,</span>    Blue<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 要序列化的数据</span>struct Person<span class="token punctuation">{</span>    <span class="token positional-class-name class-name">int</span> id<span class="token punctuation">;</span>    <span class="token builtin">string</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token builtin">string</span> sex<span class="token punctuation">;</span>    <span class="token positional-class-name class-name">int</span> age<span class="token punctuation">;</span>    <span class="token comment">// 枚举类型</span>    <span class="token positional-class-name class-name">Color</span> color<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-包-package"><a href="#3-2-包-package" class="headerlink" title="3.2 包(package)"></a>3.2 包(package)</h2><p> 在 Protobuf 中，可以使用package关键字来定义一个消息所属的包（package）。包是用于组织和命名消息类型的一种机制，类似于命名空间的概念。</p><p>在一个.proto文件中，可以通过在顶层使用package关键字来定义包：<br></p><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token keyword">package</span> mypackage<span class="token punctuation">;</span><span class="token keyword">message</span> <span class="token class-name">MyMessage</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在这个示例中，我们使用package关键字将MyMessage消息类型定义在名为mypackage的包中。包名作为一个标识符来命名，可以使用任何有效的标识符，按惯例使用小写字母和下划线。<p></p><p>使用包可以避免不同.proto文件中的消息类型名称冲突，同时也可以更好地组织和管理大型项目中的消息定义。可以将消息类型的名称定义在特定的包中，并使用限定名来引用这些类型。</p><h1 id="4-示例"><a href="#4-示例" class="headerlink" title="4 示例"></a>4 示例</h1><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token keyword">package</span> Dabing<span class="token punctuation">;</span><span class="token keyword">message</span> <span class="token class-name">Address</span><span class="token punctuation">{</span>  <span class="token builtin">int32</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token builtin">bytes</span> addr <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-protobuf" data-language="protobuf"><code class="language-protobuf"><span class="token keyword">syntax</span> <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment">// 使用另外一个proto文件中的数类型, 需要导入这个文件</span><span class="token keyword">import</span> <span class="token string">"Address.proto"</span><span class="token punctuation">;</span><span class="token comment">// 指定命名空间 ErBing</span><span class="token keyword">package</span> Erbing<span class="token punctuation">;</span><span class="token comment">// 以下的类 Person 和枚举 Color 都属于命名空间 ErBing</span><span class="token comment">// 在该文件中对要序列化的结构体进行描述</span><span class="token comment">// 定义枚举类型</span><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    Red <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      Green <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment">// 第一个元素以外的元素值可以随意指定</span>    Yellow <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    Blue <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token builtin">int32</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">repeated</span> <span class="token builtin">bytes</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token builtin">bytes</span> sex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token builtin">int32</span> age <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token comment">// 添加地址信息, 使用的是外部proto文件中定义的数据类型</span>    <span class="token comment">// 如果这个外边类型属于某个命名空间, 语法格式:</span>    <span class="token comment">// 命名空间的名字.类名 变量名=编号;</span>    <span class="token positional-class-name class-name">Dabing<span class="token punctuation">.</span>Address</span> addr <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token positional-class-name class-name">Color</span> color <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include "MyTest.h"#include "Person.pb.h"//using namespace Dabing;//using namespace Erbing;void MyTest::test(){    // 序列化    Erbing::Person p;    p.set_id(10);    p.set_age(32);    p.set_sex("man");    p.add_name();    p.set_name(0,"路飞");    p.add_name("艾斯");    p.add_name("萨博");    p.mutable_addr()-&gt;set_addr("北京市长安区天安门");    p.mutable_addr()-&gt;set_num(1001);    p.set_color(Erbing::Color::Blue);    // 序列化对象 p, 最终得到一个字符串    std::string output;    p.SerializeToString(&amp;output);    // 反序列化数据    Erbing::Person pp;    pp.ParseFromString(output);    std::cout &lt;&lt; pp.id()  &lt;&lt; ", " &lt;&lt; pp.sex() &lt;&lt; ", " &lt;&lt; pp.age() &lt;&lt; std::endl;    std::cout &lt;&lt; pp.addr().addr() &lt;&lt; ", " &lt;&lt; pp.addr().num() &lt;&lt; std::endl;    int size = pp.name_size();    for(int i=0; i&lt;size; ++i)    {        std::cout &lt;&lt; pp.name(i) &lt;&lt; std::endl;    }    std::cout &lt;&lt; pp.color() &lt;&lt; std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-生成服务"><a href="#5-生成服务" class="headerlink" title="5 生成服务"></a>5 生成服务</h1><pre class="line-numbers language-proto" data-language="proto"><code class="language-proto">syntax = "proto3";option cc_generic_services = true;  // 生成服务message makeOrderRequest {    int32 price = 1;    string goods = 2;}message makeOrderResponse {    int32 ret_code = 1;    string res_info = 2;    string order_id = 3;}service Order {    rpc makeOrder(makeOrderRequest) returns (makeOrderResponse);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU编程</title>
      <link href="/c/gpu-bian-cheng/"/>
      <url>/c/gpu-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一-GPU结构"><a href="#一-GPU结构" class="headerlink" title="一 GPU结构"></a>一 GPU结构</h2><p><strong>提出问题</strong></p><p>1、GPU是如何与CPU协调工作的？</p><p>2、GPU也有缓存机制吗？有几层？它们的速度差异多少？<br><br>有的</p><p>3、GPU的渲染流程有哪些阶段？它们的功能分别是什么？</p><p>4、Early-Z技术是什么？发生在哪个阶段？这个阶段还会发生什么？会产生什么问题？如何解决？</p><p>5、SIMD和SIMT是什么？它们的好处是什么？co-issue呢？</p><p>6、GPU是并行处理的么？若是，硬件层是如何设计和实现的？</p><p>7、GPC、TPC、SM是什么？Warp又是什么？它们和Core、Thread之间的关系如何？</p><p>8、顶点着色器（VS）和像素着色器（PS）可以是同一处理单元吗？为什么？</p><p>9、像素着色器（PS）的最小处理单位是1像素吗？为什么？会带来什么影响？</p><p>10、Shader中的if、for等语句会降低渲染效率吗？为什么？</p><p>11、如下图，渲染相同面积的图形，三角形数量少（左）的还是数量多（右）的效率更快？为什么？</p><p>12、GPU Context是什么？有什么作用？</p><p>13、造成渲染瓶颈的问题很可能有哪些？该如何避免或优化它们？</p><h3 id="1-1-GPU的功能"><a href="#1-1-GPU的功能" class="headerlink" title="1.1 GPU的功能"></a>1.1 GPU的功能</h3><ul><li><p>图形绘制 <br><br>这是GPU最传统的拿手好戏，也是最基础、最核心的功能。为大多数PC桌面、移动设备、图形工作站提供图形处理和绘制功能。</p></li><li><p>物理模拟。<br><br>GPU硬件集成的物理引擎（PhysX、Havok），为游戏、电影、教育、科学模拟等领域提供了成百上千倍性能的物理模拟，使得以前需要长时间计算的物理模拟得以实时呈现。</p></li><li><p>海量计算<br><br>计算着色器及流输出的出现，为各种可以并行计算的海量需求得以实现，<strong>CUDA</strong>就是最好的例证。</p></li><li><p>AI运算<br><br>近年来，人工智能的崛起推动了GPU集成了AI Core运算单元，反哺AI运算能力的提升，给各行各业带来了计算能力的提升。</p></li><li><p>其它计算<br><br>音视频编解码、加解密、科学计算、离线渲染等等都离不开现代GPU<br>的并行计算能力和海量吞吐能力。</p></li></ul><h3 id="1-2-GPU物理结构"><a href="#1-2-GPU物理结构" class="headerlink" title="1.2 GPU物理结构"></a>1.2 GPU物理结构</h3><p><img src="imgs/cpu_gpu.png" alt="Alt text"></p><h4 id="1-2-1-Tesla-和-Turing-架构的-GPU"><a href="#1-2-1-Tesla-和-Turing-架构的-GPU" class="headerlink" title="1.2.1 Tesla 和 Turing 架构的 GPU"></a>1.2.1 Tesla 和 Turing 架构的 GPU</h4><p><img src="imgs/tesla_gpu.png" alt="NVidia Tesla架构"><br>Tesla微观架构总览图如上。下面将阐述它的特性和概念：</p><ul><li>拥有7组<strong>TPC</strong>（Texture/Processor Cluster，纹理处理簇）</li><li>每个TPC有两组<strong>SM</strong>（Stream Multiprocessor，流多处理器）</li><li>每个SM包含：<br><br>   6个<strong>SP</strong>（Streaming Processor，流处理器）<br><br>   2个<strong>SFU</strong>（Special Function Unit，特殊函数单元）<br><br>   L1缓存、MT Issue（多线程指令获取）、C-Cache（常- 量缓存）、共享内存</li><li>除了TPC核心单元，还有与显存、CPU、系统内存交互的各种部件。</li></ul><p><img src="imgs/NVidia_Turing架构.png" alt="NVidia Turing架构"><br>上图是采纳了Turing架构的TU102 GPU，它的特点如下：</p><ul><li><p>6 GPC（图形处理簇）</p></li><li><p>36 TPC（纹理处理簇）</p></li><li><p>72 SM（流多处理器）</p></li><li><p>每个GPC有6个TPC，每个TPC有2个SM</p></li><li><p>4,608 CUDA核</p></li><li><p>72 RT核</p></li><li><p>576 Tensor核</p></li><li><p>288 纹理单元</p></li><li><p>12x32位 GDDR6内存控制器 (共384位)</p></li></ul><p>单个SM的结构图如下：<br><img src="imgs/SM的结构.png" alt="SM的结构"></p><p>每个SM包含：</p><pre><code>64 CUDA核8 Tensor核256 KB寄存器文件</code></pre><h4 id="1-2-2-GPU架构的共性"><a href="#1-2-2-GPU架构的共性" class="headerlink" title="1.2.2 GPU架构的共性"></a>1.2.2 GPU架构的共性</h4><p>纵观上一节的所有GPU架构，可以发现它们虽然有所差异，但存在着很多相同的概念和部件：</p><pre><code>GPC 图形处理簇TPC 纹理处理簇Thread SM、SMX、SMM 流多处理器Warp 线程束SP 流处理器CoreALU 逻辑运算单元FPU 浮点数单元SFU 特殊函数单元ROP (render output unit) 渲染输入单元Load/Store Unit 加载存储单元L1 CacheL2 CacheMemoryRegister File 寄存器</code></pre><p>GPU为什么会有这么多层级且有这么多雷同的部件？答案是GPU的任务是天然并行的，现代GPU的架构皆是以高度并行能力而设计的。</p><h3 id="1-3-GPU-运行机制"><a href="#1-3-GPU-运行机制" class="headerlink" title="1.3 GPU 运行机制"></a>1.3 GPU 运行机制</h3><p><img src="imgs/Fermi架构的运行机制总览图.png" alt="Alt text"><br>从Fermi开始NVIDIA使用类似的原理架构，使用一个Giga Thread Engine来管理所有正在进行的工作，GPU被划分成多个GPC，每个GPC拥有多个SM（SMX、SMM，Streaming Multiprocessor 流式多处理器 是GPU的基础单元，AMD叫CU ）和一个光栅化引擎(Raster Engine)，这些部件通过总线所连接，例如图中所展示的Crossbar（交叉式总线），用来连接连接GPC和其它功能性模块（例如ROP(render output unit，渲染输出单元)或其他子系统）。</p><p>程序员编写的shader是在SM上完成的。每个SM包含许多为线程执行数学运算的Core（核心）。例如，一个线程可以是顶点或像素着色器调用。这些Core和其它单元由Warp Scheduler驱动，Warp Scheduler管理一组32个线程作为Warp（线程束）并将要执行的指令移交给Dispatch Units。</p><p>渲染流程:</p><h3 id="1-4-GPU-技术要点"><a href="#1-4-GPU-技术要点" class="headerlink" title="1.4 GPU 技术要点"></a>1.4 GPU 技术要点</h3><h4 id="1-4-1-SIMD-SIMT-if-else语句"><a href="#1-4-1-SIMD-SIMT-if-else语句" class="headerlink" title="1.4.1 SIMD  SIMT  if-else语句"></a>1.4.1 SIMD  SIMT  if-else语句</h4><p><strong>1</strong> SIMD(Single Instruction Multiple Data)即单指令流多数据<br><br>是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。简单来说就是一个指令能够同时处理多个数据。<br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">float4 c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// shader指令, a, b都是float4类型</span><span class="token comment">// 没有SIMD，需要4条指令将4个float数值相加，汇编伪代码如下:</span>ADD c<span class="token punctuation">.</span>x<span class="token punctuation">,</span> a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> b<span class="token punctuation">.</span>xADD c<span class="token punctuation">.</span>y<span class="token punctuation">,</span> a<span class="token punctuation">.</span>y<span class="token punctuation">,</span> b<span class="token punctuation">.</span>yADD c<span class="token punctuation">.</span>z<span class="token punctuation">,</span> a<span class="token punctuation">.</span>z<span class="token punctuation">,</span> b<span class="token punctuation">.</span>zADD c<span class="token punctuation">.</span>w<span class="token punctuation">,</span> a<span class="token punctuation">.</span>w<span class="token punctuation">,</span> b<span class="token punctuation">.</span>w<span class="token comment">// 但有了SIMD技术，只需一条指令即可处理完</span>SIMD_ADD c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>2</strong> SIMT（Single Instruction Multiple Threads，单指令多线程）<br><br>是SIMD的升级版，可对GPU中单个SM中的多个Core同时处理同一指令，并且每个Core存取的数据可以是不同的。<br></p><pre class="line-numbers language-none"><code class="language-none">SIMT_ADD c, a, b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>上述指令会被同时送入在单个SM中被编组的所有Core中，同时执行运算，且a、b 、c的值可以不一样.<p></p><p><strong>3</strong> if - else语句<br><img src="imgs/if-else语句.png" alt="if-else语句"></p><p>如上图，SM中有8个ALU（Core），由于SIMD的特性，每个ALU的数据不一样，导致if-else语句在某些ALU中执行的是true分支（黄色），有些ALU执行的是false分支（灰蓝色），这样导致很多ALU的执行周期被浪费掉了（即masked out），拉长了整个执行周期。最坏的情况，同一个SM中只有1/8（8是同一个SM的线程数，不同架构的GPU有所不同）的利用率。</p><p>同样，for循环也会导致类似的情形，例如以下shader代码：<br></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(int count, int breakNum){for(int i=0; i&lt;count; ++i){if (i == breakNum)break;else// do something}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>由于每个ALU的count不一样，加上有break分支，导致最快执行完shader的ALU可能是最慢的N分之一的时间，但由于SIMD的特性，最快的那个ALU依然要等待最慢的ALU执行完毕，才能接下一组指令的活！也就白白浪费了很多时间周期。<p></p><h3 id="1-5-GPU-资源机制"><a href="#1-5-GPU-资源机制" class="headerlink" title="1.5 GPU 资源机制"></a>1.5 GPU 资源机制</h3><h4 id="1-5-1-GPU-内存架构"><a href="#1-5-1-GPU-内存架构" class="headerlink" title="1.5.1 GPU 内存架构"></a>1.5.1 GPU 内存架构</h4><p>部分架构的GPU与CPU类似，也有多级缓存结构：寄存器、L1缓存、L2缓存、GPU显存、系统显存。<br><img src="imgs/内存架构.png" alt="内存架构"><br>它们的存取速度从寄存器到系统内存依次变慢：<br>|存储类型 |    寄存器 |    共享内存 |    L1缓存 |    L2缓存 |    纹理、常量缓存     全局内存|<br>|—-|—-|—-|—-|—-|—-|<br>|访问周期 |    1 |    1~32     1~32 |    32~64 |    400~600 |    400~600|</p><p>由此可见，shader直接访问寄存器、L1、L2缓存还是比较快的，但访问纹理、常量缓存和全局内存非常慢，会造成很高的延迟。</p><p>上面的多级缓存结构可被称为“CPU-Style”<br><img src="imgs/GPU-Style的内存架构.png" alt="Alt text"><br>这种架构的特点是ALU多，GPU上下文（Context）多，吞吐量高，依赖高带宽与系统内存交换数据。</p><p><strong>CPU-GPU异构系统</strong></p><p>根据CPU和GPU是否共享内存，可分为两种类型的CPU-GPU架构：<br><img src="imgs/CPU-GPU异构系统.png" alt="Alt text"></p><p>上图左是<strong>分离式架构</strong>，CPU和GPU各自有独立的缓存和内存，它们通过PCI-e等总线通讯。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>上图右是<strong>耦合式架构</strong>，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p><p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 CPU 共享系统内存，由 MMU 进行存储管理。</p><p><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的自拍</title>
      <link href="/qi-ta/jia-mi-ce-shi/"/>
      <url>/qi-ta/jia-mi-ce-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/honlzl/picgo_public/img/Algorithm/football_team.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序和归并排序</title>
      <link href="/suan-fa/kuai-su-pai-xu-he-gui-bing-pai-xu/"/>
      <url>/suan-fa/kuai-su-pai-xu-he-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1 排序"></a>1 排序</h3><h4 id="1-1-快速排序"><a href="#1-1-快速排序" class="headerlink" title="1.1 快速排序"></a>1.1 快速排序</h4><ul><li>确定分界点，这里以中间点作为分界点 x=q[l+r&gt;&gt;1]</li><li>划分两个区间，左边区间 $\le x$, 右边 区间 $\ge x$ </li><li>递归处理左右两个区间</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r){    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while (i &lt; j)    {        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        // 改为从大到小排序        // do i++; while(q[i] &gt; x); // 这里和下面        // do j--; while(q[j] &lt; x); // 这行的判断条件改一下        if (i &lt; j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用：求第k小</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int quick_sort(int l,int r,int k){    if(l&gt;=r) return q[l];    int x=q[r+l&gt;&gt;1],i=l-1,j=r+1;    while(i&lt;j)    {        do i++; while(q[i]&lt;x);        do j--; while(q[j]&gt;x);        if(i&lt;j) swap(q[i],q[j]);    }    if(j-l+1&gt;=k)   return quick_sort(l,j,k);  // 第k小在左边    else return quick_sort(j+1,r,k-(j-l+1));  // 第k小一定在右边}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-归并排序"><a href="#1-2-归并排序" class="headerlink" title="1.2 归并排序"></a>1.2 归并排序</h4><ul><li>确定分界点,中间： l+r&gt;&gt;1</li><li>先递归排序左右两个区间</li><li>合并子问题</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[], int l, int r){    if(l &gt;= r) return;     //递归的终止情况    int mid = l + r &gt;&gt; 1;  //第一步：分成子问题    //第二步：递归处理子问题    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    //第三步：合并有序的两段，i，j为两段的起点    int k = 0, i = l, j = mid + 1;    while(i &lt;= mid &amp;&amp; j &lt;= r)        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    // 对当前指针到终点的赋值    while(i &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];// 赋值回原数组    for( i = l,k=0; i &lt;= r; i++, k++) q[i] = tmp[k];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>求逆序对数</strong>：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ll merge_sort(int l, int r){    if(l &gt;= r) return 0;     //递归的终止情况    int mid = l + r &gt;&gt; 1;  //第一步：分成子问题    //第二步：递归处理子问题    ll res=merge_sort(l, mid) + merge_sort(mid + 1, r);    //第三步：合并有序的两段，i，j为两段的起点    int k = 0, i = l, j = mid + 1;    while(i &lt;= mid &amp;&amp; j &lt;= r)        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++],res+=mid-i+1;    // 对当前指针到终点的赋值    while(i &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];// 赋值回原数组    for( i = l,k=0; i &lt;= r; i++, k++) q[i] = tmp[k];    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is love</title>
      <link href="/uncategorized/what-is-love/"/>
      <url>/uncategorized/what-is-love/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
